# 至少有 K 个重复字符的最长子串

给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。

如果不存在这样的子字符串，则返回 0。

示例 1：

```js
输入：s = "aaabb", k = 3
输出：3
解释：最长子串为 "aaa" ，其中 'a' 重复了 3 次。
```

示例 2：

```js
输入：s = "ababbc", k = 2
输出：5
解释：最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。
```

提示：

- 1 <= s.length <= 10^4
- s 仅由小写英文字母组成
- 1 <= k <= 10^5

思路：

这道题要求找出字符串中满足每个字符出现次数都不少于 k 的最长子串长度。采用滑动窗口的思路，通过枚举不同的字符种类数 t（因为字符串只由小写英文字母组成，最多 26 种），然后在每种字符种类数下使用滑动窗口来寻找符合条件的子串。在滑动窗口移动过程中，使用一个数组 cnt 来记录每个字符的出现次数，同时通过变量 tot 记录当前窗口中出现的字符种类数，less 记录出现次数小于 k 的字符种类数，通过不断调整窗口来找到最长子串。

1. 首先初始化变量 res 为 0，用于存储最长子串长度，获取字符串 s 的长度 n。
2. 外层循环从 1 到 26（因为最多 26 种小写英文字母）枚举字符种类数 t：
   - 初始化左右指针 l 和 r 都为 0，创建一个长度为 26 的数组 cnt 用于记录字符出现次数，初始化变量 tot 为 0 表示当前窗口中的字符种类数，less 为 0 表示出现次数小于 k 的字符种类数。
   - 内层循环通过移动右指针 r 来扩展窗口：
     - 当右指针 r 移动时，增加当前字符 s[r]的出现次数 cnt[s[r].charCodeAt() - 'a'.charCodeAt()]，如果该字符出现次数变为 1，则 tot 加 1（表示新出现一种字符）且 less 加 1（因为新出现的字符出现次数小于 k），如果该字符出现次数变为 k，则 less 减 1（因为该字符出现次数达到 k，不再属于出现次数小于 k 的字符）。
     - 内层的 while 循环用于收缩窗口，当 tot（窗口中的字符种类数）大于 t 时，收缩窗口：
       - 减少左指针 l 指向的字符 s[l]的出现次数 cnt[s[l].charCodeAt() - 'a'.charCodeAt()]，如果该字符出现次数变为 k - 1，则 less 加 1（因为该字符即将成为出现次数小于 k 的字符），如果该字符出现次数变为 0，则 tot 减 1（表示该字符从窗口中消失）且 less 减 1（因为消失的字符不再属于出现次数小于 k 的字符），然后左指针 l 右移。
     - 如果 less 等于 0，说明当前窗口中的所有字符出现次数都不少于 k，更新 res 为当前窗口长度 r - l + 1 和 res 中的较大值。
     - 右指针 r 右移。
3. 最后返回 ret，即最长子串长度。

时间复杂度：外层循环最多执行 26 次，内层循环中每次移动指针的操作时间复杂度都是常数级别的，而指针最多移动 n 次（n 是字符串 s 的长度），所以总的时间复杂度为 O(26n)，即 O(n)。
空间复杂度：使用了一个长度为 26 的数组 cnt 来记录字符出现次数，空间复杂度为 O(26)，即 O(1)。

```js
var longestSubstring = function (s, k) {
  let res = 0;
  const n = s.length;
  for (let t = 1; t <= 26; t++) {
    let l = 0,
      r = 0;
    const cnt = new Array(26).fill(0);
    let tot = 0;
    let less = 0;
    while (r < n) {
      cnt[s[r].charCodeAt() - 'a'.charCodeAt()]++;
      if (cnt[s[r].charCodeAt() - 'a'.charCodeAt()] === 1) {
        tot++;
        less++;
      }
      if (cnt[s[r].charCodeAt() - 'a'.charCodeAt()] === k) {
        less--;
      }

      while (tot > t) {
        cnt[s[l].charCodeAt() - 'a'.charCodeAt()]--;
        if (cnt[s[l].charCodeAt() - 'a'.charCodeAt()] === k - 1) {
          less++;
        }
        if (cnt[s[l].charCodeAt() - 'a'.charCodeAt()] === 0) {
          tot--;
          less--;
        }
        l++;
      }
      if (less == 0) {
        res = Math.max(res, r - l + 1);
      }
      r++;
    }
  }
  return res;
};
```
