# 找到连续赢 K 场比赛的第一位玩家

有 n 位玩家在进行比赛，玩家编号依次为 0 到 n - 1 。

给你一个长度为 n 的整数数组 skills 和一个 正 整数 k ，其中 skills[i] 是第 i 位玩家的技能等级。skills 中所有整数 互不相同 。

所有玩家从编号 0 到 n - 1 排成一列。

比赛进行方式如下：

队列中最前面两名玩家进行一场比赛，技能等级 更高 的玩家胜出。
比赛后，获胜者保持在队列的开头，而失败者排到队列的末尾。
这个比赛的赢家是 第一位连续 赢下 k 场比赛的玩家。

请你返回这个比赛的赢家编号。

示例 1：

```js
输入：skills = [4,2,6,3,9], k = 2

输出：2

解释：

一开始，队列里的玩家为 [0,1,2,3,4] 。比赛过程如下：

玩家 0 和 1 进行一场比赛，玩家 0 的技能等级高于玩家 1 ，玩家 0 胜出，队列变为 [0,2,3,4,1] 。
玩家 0 和 2 进行一场比赛，玩家 2 的技能等级高于玩家 0 ，玩家 2 胜出，队列变为 [2,3,4,1,0] 。
玩家 2 和 3 进行一场比赛，玩家 2 的技能等级高于玩家 3 ，玩家 2 胜出，队列变为 [2,4,1,0,3] 。
玩家 2 连续赢了 k = 2 场比赛，所以赢家是玩家 2 。
```

示例 2：

```js
输入：skills = [2,5,4], k = 3

输出：1

解释：

一开始，队列里的玩家为 [0,1,2] 。比赛过程如下：

玩家 0 和 1 进行一场比赛，玩家 1 的技能等级高于玩家 0 ，玩家 1 胜出，队列变为 [1,2,0] 。
玩家 1 和 2 进行一场比赛，玩家 1 的技能等级高于玩家 2 ，玩家 1 胜出，队列变为 [1,0,2] 。
玩家 1 和 0 进行一场比赛，玩家 1 的技能等级高于玩家 0 ，玩家 1 胜出，队列变为 [1,2,0] 。
玩家 1 连续赢了 k = 3 场比赛，所以赢家是玩家 1 。
```

提示：

- n == skills.length
- 2 <= n <= 10^5
- 1 <= k <= 10^9
- 1 <= skills[i] <= 10^6
- skills 中的整数互不相同。

思路：

由于比赛输了的玩家会排到队列末尾，因此如果前面一直没有人是赢家（连续赢下 k 次），那么 skills 值最高的那个玩家就是赢家。因此，我们从前到后去遍历 i，判断它能否连续赢下 k 次。若能，则直接返回答案，否则继续遍历，直到末尾。若仍没找到，则返回 skills 值最高的那个玩家。

需要注意的是，如果 i 不为 0，那么第 i 个玩家最少已经赢了一次（与 i 进行比赛的上一个玩家，输掉后排到末尾）。我们用 cnt 来表示当前玩家赢得次数，初始值为 0，然后每次遍历下一个 i 时，赋值为 1。

另外，玩家 i 后面那些输掉比赛的玩家一定不是赢家，因为要么玩家 i 是赢家，要么玩家 i 后面还有一个 skills 值更高的玩家，并且与玩家 i 相隔不超过 k（或者 k−1）。

时间复杂度：O(n)，其中 n 是 skills 的长度。由于每个元素最多遍历一次，因此总体的时间复杂度为 O(n)。
空间复杂度：O(1)，只使用了若干个变量。

```js
var findWinningPlayer = function(skills, k) {
  const n = skills.length;
  let cnt = 0;
  let i = 0, last_i = 0;

  while (i < n) {
    let j = i + 1; 
    while (j < n && skills[j] < skills[i] && cnt < k) {
        j++;
        cnt++;
    }
    if (cnt === k) {
        return i;
    }
    cnt = 1;
    last_i = i;
    i = j;
  }
  return last_i;
};
```
