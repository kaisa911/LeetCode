# 非递减子序列

给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

示例 1：

```javascript
输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
```

示例 2：

```javascript
输入：nums = [4,4,3,2,1]
输出：[[4,4]]
```

提示：

- 1 <= nums.length <= 15
- -100 <= nums[i] <= 100

思路：

拿到这个题目，首先要明确我们需要找出数组中所有的递增子序列，并且子序列至少包含两个元素。因为数组可能包含重复元素，所以在判断递增时需要特殊处理相同元素的情况。我们可以通过深度优先搜索（DFS）的方法来遍历数组，尝试不同的组合，以找到所有满足条件的子序列。选择 DFS 的理由是它能够方便地处理选择和撤销选择的过程，并且可以有效地遍历所有可能的子序列组合。

1. 首先定义一个结果数组 `res` 来存储最终的递增子序列，一个长度变量 `len` 表示数组的长度，以及一个集合 `set` 用于去重。
2. 定义 `dfs` 函数，接受当前索引 `index` 和当前路径 `path` 。
3. 如果 `path` 长度大于等于 2，将其转换为字符串作为键，判断集合中不存在时，将其加入结果数组，并添加到集合中去重。
4. 如果当前索引达到数组长度，直接返回。
5. 从当前索引开始遍历数组，如果 `path` 为空或者当前数字大于等于 `path` 的最后一个数字，将其加入 `path` ，然后递归调用 `dfs` 函数，处理下一个位置，并在回溯时将当前数字弹出。

时间复杂度：O(2^n)，因为对于每个数字都有选择和不选择两种情况。
空间复杂度：O(n)，主要是递归栈的空间以及存储结果和中间路径的空间。

```javascript
const findSubsequences = (nums) => {
  const res = [];
  const len = nums.length;
  const set = new Set();

  const dfs = (index, path) => {
    if (path.length >= 2) {
      const key = path.join(',');
      if (!set.has(key)) {
        res.push([...path]);
        set.add(key);
      }
    }
    if (index === len) {
      return;
    }

    for (let i = index; i < len; i++) {
      if (path.length === 0 || nums[i] >= path[path.length - 1]) {
        path.push(nums[i]);
        dfs(i + 1, path);
        path.pop();
      }
    }
  };

  dfs(0, []);
  return res;
};
```
