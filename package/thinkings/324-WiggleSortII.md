# 摆动排序 II

给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。

你可以假设所有输入数组都可以得到满足题目要求的结果。

示例 1：

```javascript
输入：nums = [1,5,1,1,6,4]
输出：[1,6,1,5,1,4]
解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。
```

示例 2：

```javascript
输入：nums = [1,3,2,2,3,1]
输出：[2,3,1,3,1,2]
```

提示：

- 1 <= nums.length <= 5 \* 10^4
- 0 <= nums[i] <= 5000
  题目数据保证，对于给定的输入 nums ，总能产生满足题目要求的结果

进阶：你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？

思路：
对于这个题目，首先想到的思路是先对数组进行排序，然后通过特定的规则重新排列数组元素来满足摆动排序的要求。选择这种方法是因为对数组排序后，能更方便地选择合适的元素放置在相应位置。例如，较大的元素和较小的元素交替放置可以更容易地实现摆动排序。

- 直接在原数组上进行操作。
- 从索引 0 开始遍历数组。
- 对于每个索引 i，如果 i 是偶数且 nums [i] > nums [i + 1]，或者 i 是奇数且 nums [i] < nums [i + 1]，则交换 nums [i] 和 nums [i + 1] 的位置。这样不断调整相邻元素的位置，最终实现摆动排序。

时间复杂度：只需要遍历一次数组，在最坏情况下需要交换 n/2 次元素，时间复杂度为 O (n)。
空间复杂度：直接在原数组上操作，没有使用额外的空间，空间复杂度为 O (1)。

```javascript
var wiggleSort = function (nums) {
  for (let i = 0; i < nums.length; i++) {
    if ((i % 2 === 0 && nums[i] > nums[i + 1]) || (i % 2 === 1 && nums[i] < nums[i + 1])) {
      [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];
    }
  }
  return nums;
};
```
