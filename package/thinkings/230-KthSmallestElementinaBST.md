# 二叉搜索树中第 K 小的元素

给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。

示例 1：
![1](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

```js
输入：root = [3,1,4,null,2], k = 1
输出：1
```

示例 2：
![1](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

```js
输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
```

提示：

- 树中的节点数为 n 。
- 1 <= k <= n <= 10^4
- 0 <= Node.val <= 10^4

进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？

思路：

1. 使用栈进行中序遍历：使用一个栈来辅助中序遍历。从根节点开始，先遍历左子树，然后访问根节点，最后遍历右子树。
2. 遍历过程中计数：在遍历过程中，每次访问一个节点时，k 的值减 1。当 k 减到 0 时，说明已经找到了第 k 小的元素。
3. 返回结果：找到第 k 小的元素后，返回该元素的值。

时间复杂度：O(h)，其中 h 是二叉搜索树的高度。在最坏的情况下，树可能是一条链，此时高度为 n（n 为节点数）。
空间复杂度：O(h)，在最坏的情况下，栈中可能需要存储树的高度，即所有节点

如果二叉搜索树经常被修改，并且需要频繁地查找第 k 小的值，可以考虑以下优化：

1. 维护额外的树结构：维护一个额外的树结构，用于快速查找第 k 小的元素。这个树结构可以在每次树的修改时更新。
2. 使用有序集合：使用一个有序集合（如平衡二叉搜索树或红黑树）来存储树中的元素。这样，查找第 k 小的元素的时间复杂度可以降低到 O(log n)。
3. 缓存结果：如果树的修改不频繁，可以缓存之前查找的结果，以避免重复计算。

```js
var kthSmallest = function (root, k) {
  const stack = [];
  while (root != null || stack.length) {
    while (root != null) {
      stack.push(root);
      root = root.left;
    }
    root = stack.pop();
    --k;
    if (k === 0) {
      break;
    }
    root = root.right;
  }
  return root.val;
};
```
