# 生成不含相邻零的二进制字符串

给你一个正整数 n。

如果一个二进制字符串 x 的所有长度为 2 的
子字符串
中包含 至少 一个 "1"，则称 x 是一个 有效 字符串。

返回所有长度为 n 的 有效 字符串，可以以任意顺序排列。

示例 1：

```javascript
输入： n = 3
输出： ["010","011","101","110","111"]

解释：
长度为 3 的有效字符串有："010"、"011"、"101"、"110" 和 "111"。
```

示例 2：

```javascript
输入： n = 1
输出： ["0","1"]

解释：
长度为 1 的有效字符串有："0" 和 "1"。
```

提示：

- 1 <= n <= 18

思路：

对于这道题，我们的目标是生成指定长度 n 的二进制字符串，并且要保证字符串中不存在相邻的 0 。采用递归的方式是一个比较直观的思路，通过控制连续 0 的个数来决定下一步添加 0 还是 1 ，逐步构建出满足条件的字符串。这种方法能够遍历所有可能的组合，并且通过合理的条件判断来筛选出有效的字符串。

1. 首先定义一个递归函数 `dfs` ，接受当前生成的字符串 `curStr` 和连续 0 的个数 `zeroCount` 作为参数。
2. 当当前字符串长度达到 n 时，将其添加到结果数组 `res` 中。
3. 如果连续 0 的个数小于 1 ，可以添加一个 0 并增加连续 0 的个数，继续递归。
4. 无论当前情况如何，都可以添加一个 1 ，并将连续 0 的个数重置为 0 ，继续递归。

时间复杂度：O(2^n) ，因为对于每个位置都有两种选择（0 或 1），所以总的可能性为 2^n 。
空间复杂度：O(n) ，主要是递归栈的空间和结果数组的空间，递归深度最大为 n ，结果数组的长度最大为 2^n ，但每个字符串的长度为 n ，所以总的空间复杂度为 O(n) 。

```javascript
var validStrings = function (n) {
  const res = [];
  const dfs = (curStr, zeroCount) => {
    if (curStr.length === n) {
      res.push(curStr);
      return;
    }
    if (zeroCount < 1) {
      dfs(curStr + '0', zeroCount + 1);
    }
    dfs(curStr + '1', 0);
  };
  dfs('', 0);
  return res;
};
```
