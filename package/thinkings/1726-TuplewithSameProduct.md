# 同积元组

给你一个由 不同 正整数组成的数组 nums ，请你返回满足 a _b = c_ d 的元组 (a, b, c, d) 的数量。其中 a、b、c 和 d 都是 nums 中的元素，且 a != b != c != d 。

示例 1：

```js
输入：nums = [2,3,4,6]
输出：8
解释：存在 8 个满足题意的元组：
(2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)
(3,4,2,6) , (4,3,2,6) , (3,4,6,2) , (4,3,6,2)
```

示例 2：

```js
输入：nums = [1,2,4,5,10]
输出：16
解释：存在 16 个满足题意的元组：
(1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)
(2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)
(2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,5,4)
(4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2)
```

提示：

- 1 <= nums.length <= 1000
- 1 <= nums[i] <= 10^4
- nums 中的所有元素 互不相同

思路：

1. 计算所有可能的乘积：首先，遍历数组 nums 中的每一对不同的元素 (i, j)，计算它们的乘积，并将乘积作为键，出现次数作为值存储在 map 中。
2. 计算满足条件的四元组数量：遍历 map 中的每一项，对于每个键（即乘积），计算满足条件的四元组的数量。如果某个乘积出现 k 次，那么可以形成 k \* (k - 1) 对不同的四元组，因为每个乘积可以与另一个相同的乘积形成四元组，且四元组的组合方式有四种不同的排列。
3. 注意事项：在计算四元组数量时，需要排除 a = c 和 b = d 的情况，因为题目要求 a、b、c 和 d 互不相同。

时间复杂度：O(n^2)，其中 n 是数组 nums 的长度。这是因为算法需要遍历数组中的每对元素来计算乘积。
空间复杂度：O(n^2)，在最坏的情况下，可能所有的元素两两相乘得到的乘积都是不同的，这将需要存储 n^2 个键值对。

```javascript
var tupleSameProduct = function (nums) {
  const len = nums.length;
  const map = new Map();
  for (let i = 0; i < len; i++) {
    for (let j = i + 1; j < len; j++) {
      const key = nums[i] * nums[j];
      map.set(key, (map.get(key) || 0) + 1);
    }
  }
  let res = 0;
  for (const v of map.values()) {
    res += v * (v - 1) * 4;
  }
  return res;
};
```
