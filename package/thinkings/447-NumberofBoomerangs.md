# 回旋镖的数量

给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的欧式距离和 i 和 k 之间的欧式距离相等（需要考虑元组的顺序）。

返回平面上所有回旋镖的数量。

示例 1：

```javascript
输入：points = [[0,0],[1,0],[2,0]]
输出：2
解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]
```

示例 2：

```javascript
输入：points = [[1,1],[2,2],[3,3]]
输出：2
```

示例 3：

```javascript
输入：points = [[1,1]]
输出：0
```

提示：

- n == points.length
- 1 <= n <= 500
- points[i].length == 2
- -10^4 <= xi, yi <= 10^4
- 所有点都 互不相同

思路：

对于计算回旋镖数量的问题，我们可以通过计算每一个点与其他点的距离来解决。对于每一个点，我们统计出与它距离相等的点的数量。因为回旋镖要求有两个点到一个固定点的距离相等，所以对于每个距离值，其对应的点的数量m，能组成的回旋镖数量为m * (m - 1)。通过遍历所有点并重复这个过程，就能得到总的回旋镖数量。这种方法基于对回旋镖定义的数学分析，通过合理的计数来得到结果。

1. 首先初始化变量res为0，用于记录回旋镖的总数。
2. 然后通过外层循环遍历points中的每一个点p。
3. 对于每一个点p，创建一个Map对象cnt，用于记录p到其他点的距离以及相同距离的点的数量。
4. 通过内层循环遍历points中的每一个点q，计算p与q之间的欧几里得距离的平方（这里省略开方操作不影响结果且更高效），记为dis。
5. 使用Map的set方法更新cnt，将距离dis对应的数量加1（如果dis是第一次出现，则初始值设为0后再加1）。
6. 接着通过循环遍历cnt中的每一个键值对，对于每个距离对应的点的数量m，将m * (m - 1)累加到res中。
7. 最后返回res，即回旋镖的总数。


- 时间复杂度：有两层循环，外层循环遍历n个点，内层循环对于每个点也遍历n个点，时间复杂度为O(n²)，其中n是points数组中的点的数量。
- 空间复杂度：使用了一个Map来存储每个点到其他点的距离和数量，在最坏情况下，Map中可能存储n - 1个不同的距离值，空间复杂度为O(n)。

```javascript
var numberOfBoomerangs = function (points) {
  let res = 0;
  for (const p of points) {
    const cnt = new Map();
    for (const q of points) {
      const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);
      cnt.set(dis, (cnt.get(dis) || 0) + 1);
    }
    for (const [_, m] of cnt.entries()) {
      res += m * (m - 1);
    }
  }
  return res;
};
```
