# 灯泡开关

初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。

第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换第 i 个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。

找出并返回 n 轮后有多少个亮着的灯泡。

示例 1：
![1](https://assets.leetcode.com/uploads/2020/11/05/bulb.jpg)

```js
输入：n = 3
输出：1
解释：
初始时, 灯泡状态 [关闭, 关闭, 关闭].
第一轮后, 灯泡状态 [开启, 开启, 开启].
第二轮后, 灯泡状态 [开启, 关闭, 开启].
第三轮后, 灯泡状态 [开启, 关闭, 关闭].

你应该返回 1，因为只有一个灯泡还亮着。
```

示例 2：

```js
输入：n = 0
输出：0
示例 3：

输入：n = 1
输出：1
```

提示：

- 0 <= n <= 109

思路：

1. 初始化状态：所有灯泡都是关闭的。
2. 第一轮：所有灯泡都被打开。
3. 第二轮：每两个灯泡中，第二个灯泡的状态被切换。这意味着编号为偶数的灯泡都会被关闭。
4. 第三轮及以后：每 i 个灯泡中，第 i 个灯泡的状态被切换。这意味着编号为 i 的灯泡（i 从 1 开始）在第 i 轮会被切换。

我们发现，一个灯泡的状态会在它编号对应的那一轮被切换。如果一个灯泡编号是某个自然数的平方数，那么它的状态会被切换奇数次，最终是亮着的；否则，它的状态会被切换偶数次，最终是关闭的。

时间复杂度：O(1)，算法直接计算了结果，不需要遍历或迭代。
空间复杂度：O(1)，算法只使用了常量级别的额外空间。

```javascript
var bulbSwitch = function (n) {
  return Math.floor(Math.sqrt(n + 0.5));
};
```
