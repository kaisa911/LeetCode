# 非递增顺序的最小子序列

给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。

如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。

与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。

注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。

示例 1：

```javascript
输入：nums = [4,3,10,9,8]
输出：[10,9]
解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。
```

示例 2：

```javascript
输入：nums = [4,4,7,6,7]
输出：[7,7,6]
解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。
```

提示：

- 1 <= nums.length <= 500
- 1 <= nums[i] <= 100

思路：

拿到这个题目，首先要明确需要找到一个子序列，其元素之和严格大于剩余元素之和。由于要求返回长度最小且元素之和最大的非递增顺序子序列，所以考虑先对数组进行排序，然后从大到小遍历数组累加元素，直到满足子序列元素之和大于剩余元素之和的条件。选择先排序再遍历累加的方法，是因为排序可以方便地获取从大到小的元素，而遍历累加能够逐步判断是否满足条件。

1. 首先计算数组元素的总和 `total` ，并创建一个 `Map` 结构 `freq` 来存储每个数字及其出现的次数。
2. 从 100 到 1 进行遍历，如果某个数字在数组中存在（通过 `freq` 判断），则尝试将其添加到答案数组 `ans` 中，同时更新当前累加和 `curr` 以及该数字在 `freq` 中的次数。
3. 只要满足子序列元素之和大于剩余元素之和的条件，就继续添加该数字。

时间复杂度：O(n + 100)，其中 n 是数组 `nums` 的长度。创建 `freq` 结构和遍历数组需要 O(n) 的时间，从 100 到 1 的遍历需要 O(100) 的时间，所以总体时间复杂度为 O(n)。
空间复杂度：O(1)，用于存储数字出现的频率，空间复杂度相对较小。

```javascript
var minSubsequence = function (nums) {
  const total = _.sum(nums);
  const freq = new Map();
  for (const num of nums) {
    if (freq.has(num)) {
      freq.set(num, freq.get(num) + 1);
    } else {
      freq.set(num, 1);
    }
  }
  const ans = [];
  let curr = 0;
  for (let num = 100; num >= 1; num--) {
    if (freq.has(num)) {
      while (freq.get(num) > 0 && total - curr < curr) {
        ans.push(num);
        curr += num;
        freq.set(num, freq.get(num) - 1);
      }
    }
  }
  return ans;
};
```
