# 矩阵对角线元素的和

给你一个正方形矩阵 mat，请你返回矩阵对角线元素的和。

请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。

示例 1：
![](https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png)

```javascript
输入：mat = [[1,2,3],
            [4,5,6],
            [7,8,9]]
输出：25
解释：对角线的和为：1 + 5 + 9 + 3 + 7 = 25
请注意，元素 mat[1][1] = 5 只会被计算一次。
```

示例 2：

```javascript
输入：mat = [[1,1,1,1],
            [1,1,1,1],
            [1,1,1,1],
            [1,1,1,1]]
输出：8
```

示例 3：

```javascript
输入：mat = [[5]]
输出：5
```

提示：

- n == mat.length == mat[i].length
- 1 <= n <= 100
- 1 <= mat[i][j] <= 100

思路：

拿到这个题目，首先明确要处理的是一个正方形矩阵。对于计算对角线元素的和，需要遍历矩阵的行和列来获取主对角线和副对角线上的元素。选择通过两层循环遍历的方法是直观且易于理解的，因为能够直接根据矩阵的行列索引来准确获取到对角线元素。

1. 首先获取矩阵的边长 `n` 和中间位置 `mid`。
2. 初始化总和 `sum` 为 0 。
3. 通过循环遍历矩阵的每一行，将主对角线元素 `mat[i][i]` 和副对角线元素 `mat[i][n - 1 - i]` 累加到总和 `sum` 中。
4. 最后，根据矩阵边长的奇偶性，判断是否需要减去中间元素一次，以避免重复计算。

时间复杂度：O(n)，因为需要遍历矩阵的每一行，操作次数与矩阵的边长成正比。
空间复杂度：O(1)，只使用了固定的几个变量来存储中间结果和总和，不随输入矩阵的大小而变化。

```javascript
var diagonalSum = function (mat) {
  const n = mat.length,
    mid = Math.floor(n / 2);
  let sum = 0;
  for (let i = 0; i < n; ++i) {
    sum += mat[i][i] + mat[i][n - 1 - i];
  }
  return sum - mat[mid][mid] * (n & 1);
};
```
