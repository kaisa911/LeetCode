# 字符串解码

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

示例 1：

```js
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```

示例 2：

```js
输入：s = "3[a2[c]]"
输出："accaccacc"
```

示例 3：

```js
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
```

示例 4：

```js
输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

提示：

- 1 <= s.length <= 30
- s 由小写英文字母、数字和方括号 '[]' 组成
- s 保证是一个 有效 的输入。
- s 中所有整数的取值范围为 [1, 300]

思路：

这道题的关键在于处理字符串中的数字和方括号，将编码规则还原。一种可行的思路是利用栈来处理这种嵌套结构。当遇到数字时，记录数字；当遇到'[' 时，将当前的字符串和数字压入栈；当遇到 ']' 时，从栈中弹出之前的字符串和数字，按照编码规则进行重复操作；当遇到字母时，直接添加到当前字符串。原解法正是采用了栈来处理这种结构。

1. 首先初始化一个栈 stack，一个空字符串 num 用于存储数字，一个空字符串 str 用于存储当前正在构建的字符串。
2. 遍历输入字符串 s 中的每个字符 c：
   - 如果 c 是数字（这里原代码判断有误，应改为'0' <= c && c <= '9'），将其添加到 num 中，用于记录重复次数。
   - 如果 c 是'['，将当前的字符串 str 和数字 num（转换为数字类型）压入栈，然后清空 str 和 num，因为进入了新的一层编码。
   - 如果 c 是']'，从栈中弹出之前的字符串 last_str 和数字 last_num，按照编码规则将 str 重复 last_num 次，并添加到 last_str 后面，更新 str。
   - 如果 c 是字母，直接将其添加到 str 中。
3. 最后返回 str，即解码后的字符串。

时间复杂度：需要遍历一次输入字符串 s，在最坏情况下，栈操作的时间复杂度也是线性的，所以时间复杂度为 O(n)，其中 n 是字符串 s 的长度。
空间复杂度：在最坏情况下，栈中可能存储了大部分字符串内容，空间复杂度为 O(n)。

```js
/**
 * @param {string} s
 * @return {string}
 */
var decodeString = function (s) {
  let stack = [];
  let num = '';
  let str = '';
  for (c of s) {
    if (c >= 0) {
      num += c;
    } else if (c === '[') {
      stack.push([str, +num]);
      str = '';
      num = '';
    } else if (c === ']') {
      const [last_str, last_num] = stack.pop();
      str = last_str + str.repeat(last_num);
    } else {
      str += c;
    }
  }
  return str;
};
```
