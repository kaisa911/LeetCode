# 和可被 K 整除的子数组

给定一个整数数组 nums 和一个整数 k ，返回其中元素之和可被 k 整除的非空 子数组 的数目。

子数组 是数组中 连续 的部分。

示例 1：

```js
输入：nums = [4,5,0,-2,-3,1], k = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 k = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
```

示例 2:

```js
输入: (nums = [5]), (k = 9);
输出: 0;
```

提示:

- 1 <= nums.length <= 3 \* 10^4
- -10^4 <= nums[i] <= 10^4
- 2 <= k <= 10^4

思路：

拿到这个题目，首先考虑如何计算子数组的和，以及如何判断这个和能否被 k 整除。一种常见的思路是通过遍历数组，计算前缀和，然后对前缀和取模 k ，通过统计不同前缀和取模 k 结果的出现次数来计算满足条件的子数组数量。选择这种方法的理由是可以有效地利用前缀和的性质，通过对前缀和取模的结果进行分析，快速判断是否存在满足条件的子数组。

1. 首先初始化一个长度为 K 的数组 map ，并将 map[0] 置为 1 ，用于处理前缀和取模为 0 的情况。
2. 初始化前缀和 preSum 为 0 ，以及计数器 count 为 0 。
3. 遍历数组 A ，计算当前的前缀和 preSum ，对其取模 K ，如果结果为负数则加上 K 进行修正。
4. 通过 count += map[preSum] 累加满足条件的子数组数量，即当前前缀和取模 K 的结果在之前出现的次数。
5. 然后将当前前缀和取模 K 的结果在 map 中的出现次数加 1 。

时间复杂度：O(n) ，其中 n 是数组 A 的长度。需要遍历数组一次来计算前缀和和更新相关数据结构。
空间复杂度：O(k) ，用于存储长度为 K 的数组 map 。

```js
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
var subarraysDivByK = function (A, K) {
  let map = new Array(K).fill(0); // 初始化map数组，长度K
  map[0] = 1; // 预置边界情况，第0项1。其他项0
  let preSum = 0;
  let count = 0;
  for (let i = 0; i < A.length; i++) {
    preSum = (preSum + A[i]) % K;
    if (preSum < 0) preSum += K;
    count += map[preSum]; // 索引是mod，值是出现次数
    map[preSum]++; // 出现次数+1
  }
  return count;
};
```
