# 数组拆分

给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。

返回该 最大总和 。

示例 1：

```js
输入：nums = [1,4,3,2]
输出：4
解释：所有可能的分法（忽略元素顺序）为：

1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
所以最大总和为 4
```

示例 2：

```js
输入：nums = [6,2,6,5,1,2]
输出：9
解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9
```

提示：

- 1 <= n <= 10^4
- nums.length == 2 \* n
- -10^4 <= nums[i] <= 10^4

思路：

对于这个数组拆分问题，采用先对数组进行排序，然后每间隔一个元素取一个元素求和的思路是比较有效的。为了使每对中的较小值之和最大，我们希望每对中的较小值尽可能大。对数组排序后，相邻元素差值最小，每隔一个元素取一个元素（即每对中的较小值）求和，能达到总和最大的目的。

1. 首先对数组`nums`进行排序，这里使用了`nums.sort((a, b) => a - b)`来按照升序对数组进行排序。
2. 然后初始化变量`sum`为 0，用于存储总和。
3. 接着通过循环，从索引 0 开始，每次增加 2（即取每对中的较小值）：
   - 将`nums[i]`累加到`sum`中。
4. 最后返回`sum`，即为最大总和。

5. 时间复杂度：对数组进行排序，一般排序算法的时间复杂度为 O(nlogn)（这里`n`为数组`nums`的长度，`nums.length == 2 * n`）。循环遍历数组的一半长度，时间复杂度为 O(n)。总的时间复杂度由排序操作主导，为 O(nlogn)。
6. 空间复杂度：一般的排序算法在 JavaScript 中会占用 O(logn)的空间复杂度用于递归调用栈等。这里没有使用额外的大规模数据结构，除了几个变量，所以总的空间复杂度为 O(logn)。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
const arrayPairSum = (nums) => {
  nums.sort((a, b) => a - b);
  let sum = 0;
  for (let i = 0; i < nums.length; i += 2) {
    sum += nums[i];
  }
  return sum;
};
```
