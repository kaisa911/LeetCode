# 斐波那契数

斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。

示例 1：

```js
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

示例 2：

```js
输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```

示例 3：

```js
输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
```

提示：

- 0 <= n <= 30

思路：

对于计算斐波那契数这个问题，最直接的思路是按照斐波那契数列的定义进行计算。

1. 首先进行两个特殊情况的判断：
   - 如果`N`等于 0，直接返回 0，因为`F(0)=0`。
   - 如果`N`等于 1，直接返回 1，因为`F(1)=1`。
2. 然后初始化两个变量`a`为 0，`b`为 1，这分别对应斐波那契数列的前两项。
3. 从索引 2 开始循环，直到索引达到`N`。
   - 在每次循环中，计算当前斐波那契数`c`，它等于前两项`a`和`b`的和。
   - 然后更新`a`为`b`，`b`为`c`，这样`a`和`b`始终保存着计算下一个斐波那契数所需的前两项的值。
4. 最后返回`b`，即第`N`个斐波那契数。

时间复杂度：循环从 2 到`N`，循环次数为`N - 1`次，每次循环进行两次赋值运算和一次加法运算，所以时间复杂度为 O(N)。
空间复杂度：只使用了三个变量`a`、`b`和`c`来辅助计算，没有使用额外的数据结构来存储数据，所以空间复杂度为 O(1)。

```js
/**
 * @param {number} N
 * @return {number}
 */
const fib = (N) => {
  if (N === 0) return 0;
  if (N === 1) return 1;
  let a = 0,
    b = 1,
    c;
  for (let i = 2; i <= N; ++i) {
    c = a + b;
    a = b;
    b = c;
  }
  return b;
};
```
