# 解码方法

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

"1" -> 'A'

"2" -> 'B'

...

"25" -> 'Y'

"26" -> 'Z'

然而，在 解码 已编码的消息时，你意识到有许多不同的方式来解码，因为有些编码被包含在其它编码当中（"2" 和 "5" 与 "25"）。

例如，"11106" 可以映射为：

"AAJF" ，将消息分组为 (1, 1, 10, 6)
"KJF" ，将消息分组为 (11, 10, 6)
消息不能分组为 (1, 11, 06) ，因为 "06" 不是一个合法编码（只有 "6" 是合法的）。
注意，可能存在无法解码的字符串。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。如果没有合法的方式解码整个字符串，返回 0。

题目数据保证答案肯定是一个 32 位 的整数。

示例 1：

```js
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

示例 2：

```js
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

示例 3：

```js
输入：s = "06"
输出：0
解释："06" 无法映射到 "F" ，因为存在前导零（"6" 和 "06" 并不等价）。
```

提示：

- 1 <= s.length <= 100
- s 只包含数字，并且可能包含前导零。

思路：

1. 初始化：创建一个数组 f，其长度为 n + 1，其中 n 是字符串 s 的长度。数组 f[i]表示字符串 s[0...i-1]的解码方法数。初始时，f[0]设为 1，因为空字符串有一种解码方法。
2. 遍历：遍历字符串 s，对于每个索引 i（从 1 到 n）：
  - 如果当前字符 s[i - 1]不是'0'，则 f[i]可以加上 f[i - 1]，因为如果 s[i - 1]是有效的单个字符，它可以独立解码，且之前的所有解码方法都适用。
  - 如果当前索引 i 大于 1，且 s[i - 2]不是'0'，且 s[i - 2:i]构成的两位数小于或等于 26，则 f[i]可以加上 f[i - 2]，因为这意味着这两个字符可以组合成一个有效的字符。 
3. 返回结果：遍历完成后，f[n]即表示整个字符串 s 的解码方法总数。

时间复杂度：O(n)，其中 n 是字符串 s 的长度。算法只需遍历一次字符串。
空间复杂度：O(n)，因为使用了长度为 n + 1 的数组来存储中间结果。

```js
var numDecodings = function (s) {
  const n = s.length;
  const f = new Array(n + 1).fill(0);
  f[0] = 1;
  for (let i = 1; i <= n; ++i) {
    if (s[i - 1] !== '0') {
      f[i] += f[i - 1];
    }
    if (i > 1 && s[i - 2] !== '0' && (s[i - 2] - '0') * 10 + (s[i - 1] - '0') <= 26) {
      f[i] += f[i - 2];
    }
  }
  return f[n];
};
```
