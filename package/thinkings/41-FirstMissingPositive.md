# 缺失的第一个正数

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

示例 1：

```js
输入：nums = [1,2,0]
输出：3
解释：范围 [1,2] 中的数字都在数组中。
```

示例 2：

```js
输入：nums = [3,4,-1,1]
输出：2
解释：1 在数组中，但 2 没有。
```

示例 3：

```js
输入：nums = [7,8,9,11,12]
输出：1
解释：最小的正数 1 没有出现。
```

提示：

- 1 <= nums.length <= 105
- -231 <= nums[i] <= 231 - 1

思路：

1. 原地修改：我们可以通过原地修改数组来实现只使用常数级别的额外空间。
2. 标记存在：将数组中的每个数字标记为它自身值的绝对值，这样可以利用数组的索引来表示数字是否存在。
3. 查找缺失：遍历数组，找到第一个未被标记为相应数字绝对值的索引，该索引加1即为缺失的最小正数。

时间复杂度为 O(n)，因为我们需要遍历数组两次：一次是标记存在，一次是查找缺失。
空间复杂度为 O(1)，因为我们只使用了数组本身的空间，没有使用额外的空间。


```js
/**
 * 找出数组中缺失的最小正整数
 * @param {number[]} nums
 * @return {number}
 */
const firstMissingPositive = nums => {
  const n = nums.length;
  
  // 第一次遍历，将数组中的数字标记为它自身值的绝对值
  for (let i = 0; i < n; i++) {
    while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
      let temp = nums[nums[i] - 1];
      nums[nums[i] - 1] = nums[i];
      nums[i] = temp;
    }
  }
  
  // 第二次遍历，找到第一个未被标记为相应数字绝对值的索引
  for (let i = 0; i < n; i++) {
    if (nums[i] != i + 1) {
      return i + 1;
    }
  }
  
  // 如果数组中所有数字都存在，则返回数组长度加1
  return n + 1;
};
```
