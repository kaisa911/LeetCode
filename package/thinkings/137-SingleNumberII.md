# 只出现一次的数字 II

给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。

示例 1：

```js
输入：nums = [2,2,3,2]
输出：3
```

示例 2：

```js
输入：nums = [0,1,0,1,0,1,99]
输出：99
```

提示：

- 1 <= nums.length <= 3 \* 10^4
- -2^31 <= nums[i] <= 2^31 - 1
- nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次

思路

位运算思路： 我们可以使用两个变量 one 和 two 来分别记录每一位上出现一次和两次的数字的位信息：

one 用来记录出现一次的位（所有出现过一次的数字的按位累加结果）。
two 用来记录出现两次的位。
核心思路： 通过按位异或和按位与运算，更新 one 和 two 的值。最终，one 中存储的就是那个只出现一次的数字。

1. one = (one ^ num) & ~two;：

   - one ^ num：如果 num 已经出现在 one 中（即出现了一次），通过异或操作将其从 one 中去掉。如果 num 没有出现在 one 中，则将其加入 one。
   - ~two：用于清除那些已经出现在 two 中的位，这样保证 one 中只保留出现一次的数字。

2. two = (two ^ num) & ~one;：

   - two ^ num：如果 num 已经出现在 two 中（即出现了两次），通过异或操作将其从 two 中去掉。如果 num 没有出现在 two 中，则将其加入 two。
   - ~one：用于清除那些已经出现在 one 中的位，这样保证 two 中只保留出现两次的数字。

3. 最终，one 存储的就是那个只出现一次的数字。

时间复杂度：O(n)，其中 n 是数组 nums 的长度。我们只遍历了一次数组，因此时间复杂度是线性的。
空间复杂度：O(1)，我们只使用了常数空间来存储 one 和 two，所以空间复杂度是常数的。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function (nums) {
  let one = 0,
    two = 0;
  for (const num of nums) {
    one = (one ^ num) & ~two; // 处理出现一次的数字
    two = (two ^ num) & ~one; // 处理出现两次的数字
  }
  return one; // 返回只出现一次的数字
};
```
