# 使用最小花费爬楼梯

数组的每个索引做为一个阶梯，第  i 个阶梯对应着一个非负数的体力花费值  cost[i](索引从0开始)。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

示例  1:

```
输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
```

示例 2:

```
输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
```

注意：

```
cost 的长度将会在 [2, 1000]。
每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。
```

思路：
对于这个问题，我们可以从动态规划的角度思考。因为到达每一个阶梯的最小花费取决于到达前一个阶梯和前两个阶梯的最小花费。我们可以从最后一个阶梯往前推，逐步计算出到达每个阶梯的最小花费。这种方法利用了问题的递推性质，通过迭代计算可以高效地得到结果。

1. 首先获取数组 cost 的长度 len。如果长度为 0，返回 0；如果长度为 1，返回 cost[0]。
2. 然后从倒数第三个元素开始向前遍历（len - 3），因为最后两个元素不需要再计算后续的花费。
3. 对于每个元素 cost[i]，它的最小花费是到达下一个阶梯（cost[i + 1]）和下下个阶梯（cost[i + 2]）的最小花费加上自身的花费，即 cost[i] += Math.min(cost[i + 1], cost[i + 2])。
4. 最后返回到达第一个阶梯（cost[0]）和第二个阶梯（cost[1]）的最小花费中的较小值，即 Math.min(cost[0], cost[1])。

- 时间复杂度：只进行了一次从后往前的循环，循环次数最多为 n - 2 次（n 为 cost 数组长度），时间复杂度为 O(n)。
- 空间复杂度：整个过程只在原数组 cost 上进行操作，没有使用额外的数据结构来存储数据，空间复杂度为 O(1)。

```js
/**
 * @param {number[]} cost
 * @return {number}
 */
const minCostClimbingStairs = (cost) => {
  const len = cost.length;
  if (len === 0) return 0;
  if (len === 1) return cost[0];
  for (let i = len - 3; i >= 0; i--) {
    cost[i] += Math.min(cost[i + 1], cost[i + 2]);
  }
  return Math.min(cost[0], cost[1]);
};
```
