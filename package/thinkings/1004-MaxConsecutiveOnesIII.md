# 最大连续 1 的个数 III

给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。

示例 1：

```javascript
输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释：[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
```

示例 2：

```javascript
输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。
```

提示：

1 <= nums.length <= 10^5
nums[i] 不是 0 就是 1
0 <= k <= nums.length

思路：

拿到这个题目，首先明确要在给定的二进制数组中，通过翻转最多 k 个 0 来找到最长的连续 1 的子数组。初步思路是使用滑动窗口的方法，通过维护窗口左右边界来计算窗口内 0 的数量，当窗口内 0 的数量超过可翻转的数量 k 时，移动左边界，直到满足条件，同时记录每个满足条件窗口的长度，并更新最大长度。选择这种方法是因为它能够高效地处理连续子数组的问题，通过动态调整窗口来找到最优解。

1. 首先初始化左右指针 `left` 和 `right` ，以及左指针对应的累加和 `lsum` 和右指针对应的累加和 `rsum` ，还有最终的结果 `ans` 。
2. 从左到右遍历数组，每次移动右指针时，计算当前右指针位置的数字与 1 的差值并累加到 `rsum` 中。
3. 当窗口内 0 的数量（即 `rsum - lsum` ）超过可翻转的数量 k 时，移动左指针，同时更新左指针累加和 `lsum` ，以保持窗口内 0 的数量在可接受范围内。
4. 每次移动完指针后，计算当前窗口的长度 `right - left + 1` ，并与之前记录的最大长度 `ans` 比较更新。

时间复杂度：O(n)，因为只需要对数组进行一次遍历。
空间复杂度：O(1)，使用了固定数量的变量，不随输入规模变化。

```javascript
var longestOnes = function (nums, k) {
  const n = nums.length;
  let left = 0,
    lsum = 0,
    rsum = 0;
  let ans = 0;
  for (let right = 0; right < n; ++right) {
    rsum += 1 - nums[right];
    while (lsum < rsum - k) {
      lsum += 1 - nums[left];
      ++left;
    }
    ans = Math.max(ans, right - left + 1);
  }
  return ans;
};
```
