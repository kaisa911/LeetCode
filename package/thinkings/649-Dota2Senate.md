# Dota2 参议院

Dota2 的世界里有两个阵营：Radiant（天辉）和 Dire（夜魇）

Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 一 项：

禁止一名参议员的权利：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 所有的权利 。
宣布胜利：如果参议员发现有权利投票的参议员都是 同一个阵营的 ，他可以宣布胜利并决定在游戏中的有关变化。
给你一个字符串 senate 代表每个参议员的阵营。字母 'R' 和 'D'分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。

以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。

假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 "Radiant" 或 "Dire" 。

示例 1：

```js
输入：senate = "RD"
输出："Radiant"
解释：
第 1 轮时，第一个参议员来自 Radiant 阵营，他可以使用第一项权利让第二个参议员失去所有权利。
这一轮中，第二个参议员将会被跳过，因为他的权利被禁止了。
第 2 轮时，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人。
```

示例 2：

```js
输入：senate = "RDD"
输出："Dire"
解释：
第 1 轮时，第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利。
这一轮中，第二个来自 Dire 阵营的参议员会将被跳过，因为他的权利被禁止了。
这一轮中，第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利。
因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利
```

提示：

- n == senate.length
- 1 <= n <= 10^4
- senate[i] 为 'R' 或 'D'

思路：

拿到这个题目，首先要理解这是一个模拟投票过程的问题。我们需要根据参议员的阵营和他们的投票策略来判断最终哪一方获胜。由于每个参议员都足够聪明，会采取对自己阵营最优的策略，所以需要考虑如何在轮次中有效地处理参议员的权利禁止和判断哪一方最终拥有投票权。选择使用两个队列分别存储两个阵营参议员的索引，通过比较队列头部元素的索引来决定当前轮次的操作，这种方法直观且易于理解和实现。

1. 首先定义了两个计数器 `rCount` 和 `dCount` 分别记录两个阵营还存活的参议员数量，以及 `skipR` 和 `skipD` 分别记录当前轮次需要跳过的 `R` 阵营和 `D` 阵营的参议员数量。
2. 遍历输入的字符串，对于每个字符，如果是 `R` 且当前没有需要跳过它的操作，就增加 `D` 阵营需要跳过的数量，并增加 `D` 阵营存活的数量。反之亦然。
3. 在每次操作后，检查某个阵营是否存活数量为 0，如果为 0 则返回另一个阵营胜利。

时间复杂度：O(n)，其中 n 是输入字符串的长度，只需要对字符串进行一次遍历。
空间复杂度：O(1)，使用了固定数量的额外变量，不随输入规模变化。

```js
var predictPartyVictory = function (senate) {
  let rCount = 0;
  let dCount = 0;
  let skipR = 0;
  let skipD = 0;

  for (let c of senate) {
    if (c === 'R') {
      if (skipR > 0) {
        skipR--;
      } else {
        dCount++;
        skipD++;
      }
    } else {
      if (skipD > 0) {
        skipD--;
      } else {
        rCount++;
        skipR++;
      }
    }

    if (dCount === 0) {
      return 'Radiant';
    }

    if (rCount === 0) {
      return 'Dire';
    }
  }
};
```
