# 比特位计数

给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。

示例 1：

```javascript
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```

示例 2：

```javascript
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

提示：

- 0 <= n <= 10^5

思路：

这道题的解题思路可以从位运算的角度来考虑。上述代码采用了通过位运算来计算每个整数二进制表示中 1 的个数。对于 0 到 n 的每个整数，都通过 countOnes 函数来计算其 1 的个数。这种方法的好处是直接利用位运算的特性来求解，逻辑相对清晰。

1. 先初始化长度为 n + 1 的数组 bits 为 0。
2. 对于 1 到 n 的每个整数 i，利用一个规律：i 的二进制表示中 1 的个数等于 i & (i - 1) 这个数的二进制表示中 1 的个数加 1。这里 i & (i - 1) 会消除 i 二进制表示中的最低位的 1。例如，对于 i = 5（二进制 101），i - 1 = 4（二进制 100），i & (i - 1) = 4（二进制 100），5 的二进制中 1 的个数比 4 的二进制中 1 的个数多 1。

时间复杂度：只需要对 1 到 n 的每个整数进行一次简单的位运算和加法操作，时间复杂度为 O (n)。
空间复杂度：同样使用了长度为 n + 1 的数组 bits 来存储结果，空间复杂度为 O (n)。

```javascript
/**
 * @param {number} n
 * @return {number[]}
 */
var countBits = function (n) {
  const bits = new Array(n + 1).fill(0);
  for (let i = 1; i <= n; i++) {
    bits[i] = bits[i & (i - 1)] + 1;
  }
  return bits;
};
```
