# 比较含退格的字符串

给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。

注意：如果对空文本输入退格字符，文本继续为空。

示例 1：

```javascript
输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
```

示例 2：

```javascript
输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
```

示例 3：

```javascript
输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
```

提示：

- 1 <= s.length, t.length <= 200
- s 和 t 只含有小写字母以及字符 '#'

思路：

拿到这个题目，首先需要明确的是要处理字符串中的退格字符'#'，并且比较经过退格处理后的两个字符串是否相等。解题思路是从字符串的末尾开始向前遍历，同时记录每个字符串中遇到的退格数量，在遇到非'#'字符且退格数量为 0 时进行字符比较。选择这种方法的理由是可以从后往前依次处理退格和有效字符，逐步比较两个字符串对应位置的字符，能够准确模拟文本编辑的过程。

1. 首先初始化两个指针 `i` 和 `j` 分别指向两个字符串的末尾，同时初始化两个变量 `skipS` 和 `skipT` 来记录每个字符串中的退格数量。
2. 在两个嵌套的 `while` 循环中，分别处理每个字符串中的退格字符。如果遇到'#'，则增加相应的退格数量并移动指针。如果退格数量大于 0 且当前字符不是'#'，则减少退格数量并移动指针。当遇到非'#'字符且退格数量为 0 时，退出内层循环。
3. 比较两个字符串当前位置的字符，如果不相等则返回 `false` 。
4. 移动两个指针向前，并继续上述过程，直到两个指针都小于 0 。

时间复杂度：O(m + n)，其中 m 和 n 分别是字符串 `S` 和 `T` 的长度。因为需要遍历两个字符串。
空间复杂度：O(1)，只使用了固定数量的额外变量，空间消耗不随输入规模变化。

```javascript
var backspaceCompare = function (S, T) {
  let i = S.length - 1,
    j = T.length - 1,
    skipS = 0,
    skipT = 0;
  // 大循环
  while (i >= 0 || j >= 0) {
    // S 循环
    while (i >= 0) {
      if (S[i] === '#') {
        skipS++;
        i--;
      } else if (skipS > 0) {
        skipS--;
        i--;
      } else break;
    }
    // T 循环
    while (j >= 0) {
      if (T[j] === '#') {
        skipT++;
        j--;
      } else if (skipT > 0) {
        skipT--;
        j--;
      } else break;
    }
    if (S[i] !== T[j]) return false;
    i--;
    j--;
  }
  return true;
};
```
