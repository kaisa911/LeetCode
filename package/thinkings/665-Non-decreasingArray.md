# 非递减数列

给你一个长度为 n 的整数数组 nums ，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。

我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 <= i <= n-2)，总满足 nums[i] <= nums[i + 1]。

示例 1:

```javascript
输入: nums = [4,2,3]
输出: true
解释: 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。
```

示例 2:

```javascript
输入: nums = [4,2,1]
输出: false
解释: 你不能在只改变一个元素的情况下将其变为非递减数列。
```

提示：

- n == nums.length
- 1 <= n <= 10^4
- -10^5 <= nums[i] <= 10^5

思路：

对于这个题目，我们可以通过一次遍历数组来解决。因为题目要求最多改变一个元素使数组成为非递减数列，所以我们在遍历过程中统计不符合非递减条件（nums[i - 1] > nums[i]）的次数。当遇到这种情况时，我们尝试修改元素来使其满足条件，选择这种方法是因为它能直接根据题目要求进行操作，且只需要一次遍历就可能得出结果。

1. 首先，处理特殊情况，如果数组为空或者长度为 1，直接返回 true，因为这样的数组本身就是非递减数列。
2. 然后初始化一个变量 cnt 为 0，用于记录修改元素的次数，并且开始遍历数组，从索引 1 开始，当修改次数小于 2 时进行循环。
3. 当 nums[i - 1] <= nums[i]时，说明当前位置满足非递减条件，直接继续下一次循环。
4. 当遇到 nums[i - 1] > nums[i]时，将 cnt 加 1，表示进行了一次修改操作。
5. 接着判断，如果 i - 2 >= 0 且 nums[i - 2] > nums[i]，这意味着要让当前位置满足非递减，需要将 nums[i]修改为 nums[i - 1]的值。
6. 否则，将 nums[i - 1]修改为 nums[i]的值。
7. 最后，检查 cnt 是否小于等于 1，如果是，则说明在最多修改一个元素的情况下可以使数组成为非递减数列，返回 true，否则返回 false。

- 时间复杂度：只遍历了一次数组，时间复杂度为 O(n)，其中 n 是数组 nums 的长度。
- 空间复杂度：只使用了常数级别的额外变量，空间复杂度为 O(1)。

```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var checkPossibility = function (nums) {
  if (nums == null || nums.length <= 1) {
    return true;
  }
  let cnt = 0;
  for (let i = 1; i < nums.length && cnt < 2; i++) {
    if (nums[i - 1] <= nums[i]) {
      continue;
    }
    cnt++;
    if (i - 2 >= 0 && nums[i - 2] > nums[i]) {
      nums[i] = nums[i - 1];
    } else {
      nums[i - 1] = nums[i];
    }
  }
  return cnt <= 1;
};
```
