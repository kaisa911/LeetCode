# 二叉搜索树中的搜索

给定二叉搜索树（BST）的根节点 root 和一个整数值 val。

你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。

示例 1:
![](https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg)

```javascript
输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]
```

示例 2:
![](https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg)

```javascript
输入：root = [4,2,7,1,3], val = 5
输出：[]
```

提示：

- 树中节点数在 [1, 5000] 范围内
- 1 <= Node.val <= 10^7
- root 是二叉搜索树
- 1 <= val <= 10^7

思路：
对于在二叉搜索树中进行搜索的问题，由于二叉搜索树的特性（左子树的所有节点值小于根节点值，右子树的所有节点值大于根节点值），我们可以从根节点开始，通过比较目标值和当前节点值来决定是向左子树还是右子树继续搜索。这种方法充分利用了二叉搜索树的结构特点，能够高效地找到目标节点。

1. 首先进入 while 循环，只要当前节点 root 存在，就进行搜索操作。
2. 当目标值 val 等于当前节点 root 的节点值时，说明找到了目标节点，直接返回该节点。
3. 当 val 小于 root 的节点值时，根据二叉搜索树的特性，目标节点可能在左子树中，所以将 root 更新为 root.left，继续下一轮搜索。
4. 当 val 大于 root 的节点值时，目标节点可能在右子树中，将 root 更新为 root.right，继续下一轮搜索。
5. 如果循环结束后还没有找到目标节点，说明树中不存在该节点，返回 null。

- 时间复杂度：在最坏的情况下，需要遍历树的高度 h 次才能找到目标节点或确定节点不存在。对于平衡二叉搜索树，树的高度为 O(log n)，对于极端不平衡的二叉搜索树，高度可能为 O(n)，其中 n 是树中的节点数。所以时间复杂度为 O(h)，平均情况是 O(log n)，最坏情况是 O(n)。
- 空间复杂度：只使用了几个额外的指针变量，没有使用额外的数据结构来存储数据，所以空间复杂度为 O(1)。

```javascript
var searchBST = function (root, val) {
  while (root) {
    if (val === root.val) {
      return root;
    }
    root = val < root.val ? root.left : root.right;
  }
  return null;
};
```
