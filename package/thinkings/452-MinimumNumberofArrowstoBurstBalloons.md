# 用最少数量的箭引爆气球

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。

示例 1：

```javascript
输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。
```

示例 2：

```javascript
输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
解释：每个气球需要射出一支箭，总共需要4支箭。
```

示例 3：

```javascript
输入：points = [[1,2],[2,3],[3,4],[4,5]]
输出：2
解释：气球可以用2支箭来爆破:

- 在x = 2处发射箭，击破气球[1,2]和[2,3]。
- 在x = 4处射出箭，击破气球[3,4]和[4,5]。
```

提示:

- 1 <= points.length <= 10^5
- points[i].length == 2
- -2^31 <= xstart < xend <= 2^31 - 1

思路：

对于这个问题，我们可以通过贪心算法来解决。由于要使用最少数量的箭引爆所有气球，我们可以从某个气球的结束位置射出箭，尽可能多地引爆后面的气球。按照气球的结束位置进行排序后，我们可以依次遍历气球，检查当前气球的开始位置是否大于上一个已引爆气球的结束位置，如果是，则需要一支新的箭，否则可以用同一支箭引爆当前气球。这种方法的思路是尽可能地让每支箭都能引爆更多的气球，从而实现最小化箭的数量。

1. 首先处理特殊情况，如果输入的数组points为空，则直接返回0，表示不需要任何箭。
2. 然后对points数组按照气球的结束位置进行排序，这样可以方便地确定是否可以用同一支箭引爆多个气球。
3. 初始化变量pos为第一个气球的结束位置，同时初始化ans为1，表示至少需要一支箭来引爆第一个气球。
4. 遍历points数组中的每个气球：
    - 如果当前气球的开始位置大于pos，说明需要一支新的箭来引爆当前气球以及后面可能的气球。此时更新pos为当前气球的结束位置，并将ans加1。
    - 如果当前气球的开始位置小于等于pos，说明可以用同一支箭引爆当前气球，不需要更新pos和ans。
5. 最后返回ans，即引爆所有气球所需的最小箭数。

- 时间复杂度：排序操作通常需要O(n log n)的时间，其中n是points数组的长度。遍历数组需要O(n)的时间。所以总的时间复杂度为O(n log n)。
- 空间复杂度：除了几个额外的变量，没有使用额外的数据结构来存储数据，所以空间复杂度为O(1)。

```javascript
var findMinArrowShots = function (points) {
  if (!points.length) {
    return 0;
  }

  points.sort((a, b) => a[1] - b[1]);
  let pos = points[0][1];
  let ans = 1;
  for (let balloon of points) {
    if (balloon[0] > pos) {
      pos = balloon[1];
      ans++;
    }
  }
  return ans;
};
```
