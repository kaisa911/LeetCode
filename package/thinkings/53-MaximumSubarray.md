# 最大子数组和

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组
是数组中的一个连续部分。

示例 1：

```js
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

示例 2：

```js
输入：nums = [1]
输出：1
```

示例 3：

```js
输入：nums = [5,4,-1,7,8]
输出：23
```

提示：

- 1 <= nums.length <= 105
- -104 <= nums[i] <= 104

进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。

思路：

1. 初始化：设置两个变量，res用于存储到目前为止找到的最大子数组和，初始值设为负的无穷大；curSum用于存储当前子数组的和，初始值设为0。
2. 遍历数组：遍历输入数组nums中的每个元素。
3. 更新当前和：对于每个元素，更新curSum为curSum加上当前元素和当前元素之间的较大值。这一步是Kadane算法的核心，它决定了是继续加上当前元素以扩展现有的子数组，还是从当前元素开始一个新的子数组。
4. 更新最大和：在每次迭代中，更新res为res和curSum之间的较大值。
5. 返回结果：遍历结束后，返回res，即最大子数组和。

时间复杂度是O(n)，其中n是数组nums的长度。这是因为算法只需要遍历数组一次。
空间复杂度是O(1)，因为算法只需要常数级别的额外空间。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
const maxSubArray = nums => {
  let res = -Number.MAX_VALUE,
    curSum = 0;
  for (let i in nums) {
    curSum = Math.max(curSum + nums[i], nums[i]);
    res = Math.max(res, curSum);
  }
  return res;
};
```