# 滑动窗口最大值

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

示例 1：

```javascript
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

示例 2：

```javascript
输入：nums = [1], k = 1
输出：[1]
```

提示：

- 1 <= nums.length <= 10^5
- -10^4 <= nums[i] <= 10^4
- 1 <= k <= nums.length

分析
这个问题要求我们找到一个整数数组在滑动窗口中的每个窗口的最大值。滑动窗口的大小是固定的，每次向右移动一位。这个问题可以通过使用双端队列（deque）来解决，双端队列允许我们快速地从队列的两端添加或移除元素。

1. 初始化双端队列：队列中的元素代表窗口中元素的索引，且队列按照元素的值从大到小排列。
2. 填充窗口：从左到右遍历数组，对于每个元素，如果队列不为空且队列尾部的元素的值小于当前元素的值，则移除队列尾部的元素。同时，如果队列头部的元素的索引已经不在窗口内，也将其移除。
3. 更新结果：当窗口移动时，队列头部的元素就是当前窗口的最大值，将其添加到结果数组中。

思路

1. 初始化：创建一个双端队列 q 来存储当前窗口中元素的索引，以及一个结果数组 res 来存储每个窗口的最大值。
2. 填充窗口：遍历数组的前 k 个元素，对于每个元素，如果队列不为空且当前元素的值大于等于队列尾部元素的值，则移除队列尾部的元素。然后将当前元素的索引添加到队列中。
3. 更新结果：在结果数组中添加队列头部元素的值，因为队列头部的元素就是当前窗口的最大值。
4. 滑动窗口：遍历数组的剩余元素，对于每个元素，执行与步骤 2 相同的操作来更新队列。同时，如果队列头部的元素的索引已经不在窗口内，移除它。然后，将队列头部元素的值添加到结果数组中。

时间复杂度：O(n)，其中 n 是数组的长度。每个元素最多被添加和移除队列一次。
空间复杂度：O(k)，其中 k 是滑动窗口的大小。双端队列最多存储 k 个元素的索引

```javascript
var maxSlidingWindow = function (nums, k) {
  const n = nums.length;
  const q = [];
  for (let i = 0; i < k; i++) {
    while (q.length && nums[i] >= nums[q[q.length - 1]]) {
      q.pop();
    }
    q.push(i);
  }

  const res = [nums[q[0]]];
  for (let i = k; i < n; i++) {
    while (q.length && nums[i] >= nums[q[q.length - 1]]) {
      q.pop();
    }
    q.push(i);
    while (q[0] <= i - k) {
      q.shift();
    }
    res.push(nums[q[0]]);
  }
  return res;
};
```
