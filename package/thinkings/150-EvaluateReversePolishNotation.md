# 逆波兰表达式求值

给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

注意：

有效的算符为 '+'、'-'、'\*' 和 '/' 。
每个操作数（运算对象）都可以是一个整数或者另一个表达式。
两个整数之间的除法总是 向零截断 。
表达式中不含除零运算。
输入是一个根据逆波兰表示法表示的算术表达式。
答案及所有中间计算结果可以用 32 位 整数表示。

示例 1：

```javascript
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

示例 2：

```javascript
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```

示例 3：

```javascript
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 *(6 / ((9 + 3)* -11))) + 17) + 5
= ((10 *(6 / (12* -11))) + 17) + 5
= ((10 *(6 / -132)) + 17) + 5
= ((10* 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

提示：

- 1 <= tokens.length <= 10^4
- tokens[i] 是一个算符（"+"、"-"、"\*" 或 "/"），或是在范围 [-200, 200] 内的一个整数

逆波兰表达式：

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) _( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + )_ ) 。
逆波兰表达式主要有以下两个优点：

去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + \* 也可以依据次序计算出正确结果。
适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

思路：

1. 使用栈：逆波兰表达式可以通过栈来求解。遍历表达式中的每个元素：
   - 如果是数字，将其压入栈中。
   - 如果是运算符，从栈中弹出两个数字，进行相应的运算，并将结果压回栈中。
2. 处理运算符：对于每个运算符，需要从栈中弹出两个数字进行计算。注意处理除法时的向零截断。
3. 返回结果：遍历完成后，栈顶的数字即为表达式的结果。

时间复杂度：O(n)，其中 n 是 tokens 数组的长度。需要遍历数组中的每个元素一次。
空间复杂度：O(n)，在最坏的情况下，可能需要将所有的数字压入栈中。

```javascript
var evalRPN = function (tokens) {
  const stack = []; // 使用数组模拟栈

  for (const token of tokens) {
    if (token === '+' || token === '-' || token === '*' || token === '/') {
      // 从栈中弹出两个数字进行运算
      const b = stack.pop();
      const a = stack.pop();

      if (token === '+') {
        stack.push(a + b);
      } else if (token === '-') {
        stack.push(a - b);
      } else if (token === '*') {
        stack.push(a * b);
      } else if (token === '/') {
        // 处理除法，向零截断
        stack.push(Math.floor(a / b));
      }
    } else {
      // 如果是数字，直接压入栈中
      stack.push(parseInt(token));
    }
  }

  // 表达式计算完成后，栈顶的数字即为结果
  return stack.pop();
};
```
