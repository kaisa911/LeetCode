# 每日温度

给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。

示例 1:

```js
输入: temperatures = [73, 74, 75, 71, 69, 72, 76, 73];
输出: [1, 1, 4, 2, 1, 1, 0, 0];
```

示例 2:

```js
输入: temperatures = [30, 40, 50, 60];
输出: [1, 1, 1, 0];
```

示例 3:

```js
输入: temperatures = [30, 60, 90];
输出: [1, 1, 0];
```

提示：

- 1 <= temperatures.length <= 10^5
- 30 <= temperatures[i] <= 100

思路：

拿到这个题目，我们可以考虑从后往前遍历温度数组。使用一个栈来存储还未找到下一个更高温度的索引。对于每个温度，不断弹出栈顶小于等于当前温度的索引，直到栈顶的温度大于当前温度或者栈为空。如果栈不为空，那么栈顶索引减去当前索引就是下一个更高温度出现的天数，否则为 0 。选择从后往前遍历并使用栈的方法，可以方便地处理每个温度的下一个更高温度的查找，避免了重复计算。

1. 首先创建一个长度与输入温度数组相同的结果数组 `res` 并初始化为 0 ，同时创建一个空栈 `st` 用于存储索引。
2. 从数组末尾开始向前遍历。对于当前温度，获取其值 `t` 。
3. 进入一个循环，只要栈不为空且栈顶元素对应的温度小于等于当前温度，就弹出栈顶元素。这样保证栈顶元素对应的温度一定大于当前温度。
4. 如果栈不为空，那么计算栈顶索引与当前索引的差值，得到下一个更高温度出现的天数，存储在结果数组中。
5. 最后将当前索引压入栈中，以便后续元素的比较。

时间复杂度：O(n)，其中 n 是温度数组的长度。因为我们对数组进行了一次遍历。
空间复杂度：O(n)，主要是用于存储结果数组和栈，它们的最大长度都可能达到 n 。

```js
var dailyTemperatures = function (temperatures) {
  const n = temperatures.length;
  const res = new Array(n).fill(0);
  const st = [];
  for (let i = n - 1; i >= 0; i--) {
    const t = temperatures[i];
    while (st.length && t >= temperatures[st[st.length - 1]]) {
      st.pop();
    }
    if (st.length) {
      res[i] = st[st.length - 1] - i;
    }
    st.push(i);
  }
  return res;
};
```
