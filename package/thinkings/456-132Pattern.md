# 132 模式

给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。

如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。

示例 1：

```javascript
输入：nums = [1,2,3,4]
输出：false
解释：序列中不存在 132 模式的子序列。
```

示例 2：

```javascript
输入：nums = [3,1,4,2]
输出：true
解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。
```

示例 3：

```javascript
输入：nums = [-1,3,2,0]
输出：true
解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。
```

提示：

- n == nums.length
- 1 <= n <= 2 \* 10^5
- -10^9 <= nums[i] <= 10^9

思路：
对于判断数组中是否存在“132 模式”的问题，可以通过维护两个单调栈（这里用数组模拟）来解决。一个栈用于存储可能的“1”值（最小的值），另一个栈用于存储可能的“3”值（次大的值）。遍历数组时，对于每个元素，尝试找到满足“132 模式”的组合。这种方法利用了单调栈的性质，能够高效地判断是否存在特定的模式。

1. 首先初始化变量`s3`为负无穷大，表示目前还没有找到合适的“3”值。
2. 创建一个空栈`stack`用于存储可能的“2”值（最大的值）。
3. 从数组的末尾开始向前遍历。
4. 对于每个元素`nums[i]`，如果它小于`s3`，说明找到了“132 模式”，直接返回`true`。
5. 如果当前元素大于栈顶元素，说明当前元素可能是“2”值，将栈顶元素弹出并更新`s3`，直到栈为空或者当前元素小于等于栈顶元素。
6. 将当前元素压入栈中。
7. 如果遍历完整个数组都没有找到“132 模式”，则返回`false`。

- 时间复杂度：遍历一次数组，时间复杂度为`O(n)`，其中`n`是数组的长度。
- 空间复杂度：使用了一个栈来存储元素，空间复杂度为`O(n)`，在最坏情况下，栈可能存储所有元素。但在平均情况下，空间复杂度小于`O(n)`。

```javascript
var find132pattern = function(nums) {
    let s3 = -Infinity;
    const stack = [];
    for (let i = nums.length - 1; i >= 0; i--) {
        if (nums[i] < s3) {
            return true;
        }
        while (stack.length > 0 && nums[i] > stack[stack.length - 1]) {
            s3 = stack.pop();
        }
        stack.push(nums[i]);
    }
    return false;
};
```
