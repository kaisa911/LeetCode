# Pow(x, n)

实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。

示例 1：

```js
输入：x = 2.00000, n = 10
输出：1024.00000
```

示例 2：

```js
输入：x = 2.10000, n = 3
输出：9.26100
```

示例 3：

```js
输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
```

提示：

- -100.0 < x < 100.0
- -2^31 <= n <= 2^31-1
- n 是一个整数
- 要么 x 不为零，要么 n > 0 。
- -10^4 <= x^n <= 10^4

思路：

这段代码实现了快速幂算法，用于计算x的n次幂。以下是算法的逻辑流程：

1. 初始化：设置结果result为1，当前幂currentPow为x的初始值。
2. 处理负指数：如果指数n是负数，将x变为其倒数，并将n转换为正数。
3. 循环计算：
  - 使用while循环，直到指数n变为0。
  - 在每次循环中，首先检查当前的指数n是否为奇数（n % 2 === 1）。如果是奇数，将currentPow乘到结果result中。
  - 然后，将currentPow自身乘以自身（currentPow *= currentPow），实现x的幂次翻倍。
  - 接着，将指数n除以2（n = n / 2），减少幂次的规模，为下一次循环做准备。
4. 返回结果：循环结束后，返回计算结果result。

时间复杂度是O(log n)，这里的n是指数的大小。这是因为每次循环将指数减半，直到指数为0。因此，循环的次数等于指数的二进制位数，这个数值不会超过log n。
空间复杂度是O(1)，因为算法只使用了有限的几个变量来存储中间结果，不依赖于输入的大小。

```js
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
const myPow = (x, n) => {
  let result = 1;
  let currentPow = x;

  if (n < 0) {
    x = 1 / x;
    n = -n;
  }

  while (n > 0) {
    if (n % 2 === 1) {
      result *= currentPow;
    }
    currentPow *= currentPow;
    n = n / 2;
  }

  return result;
};
```
