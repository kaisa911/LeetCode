# 移动零

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

示例 1:

```javascript
输入: nums = [0, 1, 0, 3, 12];
输出: [1, 3, 12, 0, 0];
```

示例 2:

```javascript
输入: nums = [0];
输出: [0];
```

提示:

1 <= nums.length <= 10^4
-2^31 <= nums[i] <= 2^31 - 1

进阶：你能尽量减少完成的操作次数吗？

思路：

题目的整理分析
拿到这个题目，因为要求原地操作且保持非零元素相对顺序，使用双指针是一个直观且有效的思路。通过一个指针遍历数组找到非零元素，另一个指针指示非零元素应该插入的位置，这样可以在一次遍历中完成零的移动和非零元素的重新排列。

1. 首先，初始化一个指针 `left` 为 0，用于指示当前已经处理好的非零元素的位置。
2. 然后，通过遍历数组，当遇到非零元素时，将其与 `left` 位置的元素交换位置，并将 `left` 指针向右移动一位。
3. 这样，遍历结束后，`left` 指针之前的位置都是非零元素，而 `left` 指针之后的位置则是尚未处理的元素。
4. 由于非零元素都被交换到了前面，所以 `left` 指针之后的位置直接填充 0 即可。

时间复杂度：O(n)，需要遍历整个数组一次，其中 n 是数组的长度。
空间复杂度：O(1)，只使用了固定的几个变量，没有额外的空间开销，是原地操作。

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
const moveZeroes = (nums) => {
  if (!nums.length) return [];
  let left = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {
      [nums[left], nums[i]] = [nums[i], nums[left]];
      left += 1;
    }
  }
  return nums;
};
```
