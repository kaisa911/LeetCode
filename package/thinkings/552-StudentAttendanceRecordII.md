# 学生出勤记录 II

可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
'A'：Absent，缺勤
'L'：Late，迟到
'P'：Present，到场
如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：

按 总出勤 计，学生缺勤（'A'）严格 少于两天。
学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（'L'）记录。
给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 的结果。

示例 1：

```js
输入：n = 2
输出：8
解释：
有 8 种长度为 2 的记录将被视为可奖励：
"PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL"
只有"AA"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。
```

示例 2：

```js
输入：n = 1
输出：3
```

示例 3：

```js
输入：n = 10101
输出：183236316
```

提示：

- 1 <= n <= 105

思路

1. 定义状态：使用三维数组 dp[i][j][k]来存储状态，其中 i 表示出勤记录的长度，j 表示缺勤（'A'）的次数（0 或 1），k 表示记录以连续迟到（'L'）结尾的数量（0、1 或 2）。
2. 初始化：dp[0][0][0] = 1，表示长度为 0 的记录（没有出勤记录）是有效的。
3. 状态转移：
   - 以'P'结尾：对于每个状态(i, j, k)，可以从状态(i - 1, j, l)转移而来，其中 l 为 0、1 或 2。
   - 以'A'结尾：对于每个状态(i, 1, k)，可以从状态(i - 1, 0, k)转移而来，因为只能有至多一次缺勤。
   - 以'L'结尾：对于每个状态(i, j, k)，可以从状态(i - 1, j, k - 1)转移而来，其中 k 大于 0。
4. 计算结果：遍历所有可能的状态，累加所有满足条件的记录数量。
5. 返回结果：返回累加的结果，对 10^9 + 7 取余。

时间复杂度：O(n^2)，其中 n 是出勤记录的长度。需要填充一个 n+1×2×3 的三维数组。
空间复杂度：O(n^2)，用于存储动态规划数组。

```js
var checkRecord = function (n) {
  const MOD = 10 ** 9 + 7;
  // 长度，A 的数量，结尾连续 L 的数量
  const dp = new Array(n + 1)
    .fill(2)
    .map(() => new Array(2).fill(0).map(() => new Array(3).fill(0)));
  dp[0][0][0] = 1;
  for (let i = 1; i <= n; i++) {
    // 以 P 结尾的数量
    for (let j = 0; j <= 1; j++) {
      for (let k = 0; k <= 2; k++) {
        dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % MOD;
      }
    }
    // 以 A 结尾的数量
    for (let k = 0; k <= 2; k++) {
      dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % MOD;
    }
    // 以 L 结尾的数量
    for (let j = 0; j <= 1; j++) {
      for (let k = 1; k <= 2; k++) {
        dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % MOD;
      }
    }
  }
  let res = 0;
  for (let j = 0; j <= 1; j++) {
    for (let k = 0; k <= 2; k++) {
      res = (res + dp[n][j][k]) % MOD;
    }
  }
  return res;
};
```
