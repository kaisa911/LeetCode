# 买卖股票的最佳时机含冷冻期

给定一个整数数组 prices，其中第 prices[i] 表示第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

```javascript
输入: prices = [1, 2, 3, 0, 2];
输出: 3;
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出];
```

示例 2:

```javascript
输入: prices = [1];
输出: 0;
```

提示：

- 1 <= prices.length <= 5000
- 0 <= prices[i] <= 1000

分析：
这个问题是一个变种的买卖股票问题，其中增加了一个约束条件：卖出股票后的第二天不能买入股票。这要求我们在计算最大利润时，需要考虑交易之间的“冷冻期”。

1. 状态定义：
   - hold[i]：第 i 天持有股票的最大利润。
   - unhold[i]：第 i 天不持有股票的最大利润。
2. 状态转移方程：
   - hold[i]：第 i 天持有股票的最大利润可以通过两种方式获得：
     - 第 i-1 天也持有股票，那么利润不变，即 hold[i-1]。
     - 第 i-1 天不持有股票，且在第 i 天买入股票，但由于存在冷冻期，必须在第 i-2 天卖出股票，即 unhold[i-2] - prices[i]。
   - unhold[i]：第 i 天不持有股票的最大利润可以通过两种方式获得：
     - 第 i-1 天也不持有股票，那么利润不变，即 unhold[i-1]。
     - 第 i-1 天持有股票，且在第 i 天卖出股票，即 hold[i-1] + prices[i]。
3. 初始化：
   - hold[0]：第 0 天持有股票的最大利润为-prices[0]（因为买入了股票）。
   - unhold[0]：第 0 天不持有股票的最大利润为 0。
4. 遍历顺序：
   - 从第 1 天开始遍历到第 n-1 天，根据状态转移方程更新 hold 和 unhold 数组。
5. 结果：
   - 最终，unhold[n-1]即为第 n 天不持有股票时的最大利润，也就是整个问题的解。

思路：

1. 初始化状态：设置 hold 和 unhold 数组，分别表示持有和不持有股票的最大利润。
2. 遍历天数：从第 1 天开始遍历到最后一天，根据前一天的状态更新当前天的状态。
3. 处理特殊情况：在第 1 天时，由于没有前一天的状态，需要单独处理。
4. 状态转移：对于每一天，根据是否持有股票，更新 hold 和 unhold 的状态。
5. 返回结果：遍历完成后，unhold 数组的最后一个元素即为最大利润。

时间复杂度：O(n)，其中 n 是天数。因为我们需要遍历每一天，对于每一天，我们只进行常数时间的操作。
空间复杂度：O(n)，我们需要两个数组 hold 和 unhold 来存储每一天的状态，每个数组的大小与天数相同。如果只使用一个数组来交替存储状态，可以将空间复杂度降低到 O(1)。

```javascript
const maxProfit = (prices) => {
  const n = prices.length; // n天
  if (n == 0) return 0;
  let hold = new Array(n); // 第i天持有股票的最大收益
  let unhold = new Array(n); // 第i天不持有股票的最大收益
  hold[0] = -prices[0]; // 第0天 买了股票的收益
  unhold[0] = 0;
  for (let i = 1; i < n; i++) {
    if (i == 1) {
      // base case
      hold[i] = Math.max(hold[i - 1], -prices[1]);
    } else {
      hold[i] = Math.max(hold[i - 1], unhold[i - 2] - prices[i]);
    }
    unhold[i] = Math.max(unhold[i - 1], hold[i - 1] + prices[i]);
  }
  return unhold[n - 1];
};
```
