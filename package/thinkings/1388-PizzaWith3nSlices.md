# 3n 块披萨

给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：

你挑选 任意 一块披萨。
Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。
Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。
重复上述过程直到没有披萨剩下。
每一块披萨的大小按顺时针方向由循环数组 slices 表示。

请你返回你可以获得的披萨大小总和的最大值。

示例 1：
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_3_1723.png)

```javascript
输入：slices = [1,2,3,4,5,6]
输出：10
解释：选择大小为 4 的披萨，Alice 和 Bob 分别挑选大小为 3 和 5 的披萨。然后你选择大小为 6 的披萨，Alice 和 Bob 分别挑选大小为 2 和 1 的披萨。你获得的披萨总大小为 4 + 6 = 10 。
```

示例 2：
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_4_1723.png)

```javascript
输入：slices = [8,9,8,6,1,1]
输出：16
解释：两轮都选大小为 8 的披萨。如果你选择大小为 9 的披萨，你的朋友们就会选择大小为 8 的披萨，这种情况下你的总和不是最大的。
```

提示：

- 1 <= slices.length <= 500
- slices.length % 3 == 0
- 1 <= slices[i] <= 1000

思路：

题目的整理分析
拿到这个题目，首先明确这是一个关于选择和优化的问题。由于每个人选择披萨有特定的顺序规则，且需要计算自己能获得的披萨大小总和的最大值，初步思路可以考虑使用动态规划来解决。选择动态规划的理由是它适合处理这种有多个阶段、每个阶段有多种选择并且需要求最优解的问题。通过逐步计算每个状态下能获得的最大总和，最终得到整个问题的最优解。

1. 首先，初始化一个二维数组 `dp` 来存储中间计算的结果。
2. 对于 `dp` 数组的初始化，当 `i` 为 0 时，如果选择 1 块披萨则为当前的 `slices[i]` ，否则为 0 。当 `j` 为 0 时，总和为 0 。
3. 进入双重循环计算每个状态下的最大值。对于当前位置 `(i, j)` ，有两种选择：不选择当前披萨，即 `dp[i - 1][j]` ；选择当前披萨，即 `(i - 1 >= 0? dp[i - 2][j - 1] : 0) + slices[i]` ，然后取两者中的最大值。
4. 最后，比较去除开头和去除结尾两种情况下的最大值作为最终结果。

时间复杂度：O(nk)，其中 n 是披萨的数量，k 是能选择的披萨数量。
空间复杂度：O(nk)，用于存储 `dp` 数组。

```javascript
var maxSizeSlices = (slices) => {
  const n = slices.length;
  const k = Math.floor(n / 3);

  const dp = new Array(n).fill(0).map(() => new Array(k + 1).fill(0));

  for (let i = 0; i < n; i++) {
    for (let j = 0; j <= k; j++) {
      if (i === 0) {
        dp[i][j] = j === 1 ? slices[i] : 0;
      } else if (j === 0) {
        dp[i][j] = 0;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], (i - 1 >= 0 ? dp[i - 2][j - 1] : 0) + slices[i]);
      }
    }
  }

  let res = Math.max(dp[n - 2][k], dp[n - 1][k]);
  return res;
};
```
