# 任务调度器

给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表，用字母 A 到 Z 表示，以及一个冷却时间 n。每个周期或时间间隔允许完成一项任务。任务可以按任何顺序完成，但有一个限制：两个 相同种类 的任务之间必须有长度为 n 的冷却时间。

返回完成所有任务所需要的 最短时间间隔 。

示例 1：

```js
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：
在完成任务 A 之后，你必须等待两个间隔。对任务 B 来说也是一样。在第 3 个间隔，A 和 B 都不能完成，所以你需要待命。在第 4 个间隔，由于已经经过了 2 个间隔，你可以再次执行 A 任务。
```

示例 2：

```js
输入：tasks = ["A","C","A","B","D","B"], n = 1

输出：6

解释：一种可能的序列是：A -> B -> C -> D -> A -> B。

由于冷却间隔为 1，你可以在完成另一个任务后重复执行这个任务。
```

示例 3：

```js
输入：tasks = ["A","A","A","B","B","B"], n = 3
输出：10
解释：一种可能的序列为：A -> B -> idle -> idle -> A -> B -> idle -> idle -> A -> B。
只有两种任务类型，A 和 B，需要被 3 个间隔分割。这导致重复执行这些任务的间隔当中有两次待命状态。
```

提示：

- 1 <= tasks.length <= 10^4
- tasks[i] 是大写英文字母
- 0 <= n <= 100

思路：

拿到这个题目，首先需要统计每个任务出现的频率，找到出现频率最高的任务次数`maxExec`以及具有相同最高频率的任务数量`maxCount`。解题思路是通过计算以最高频率任务为基准，考虑冷却时间间隔，计算出一个可能的最短时间，然后与任务总数进行比较取较大值。选择这种方法的理由是，通过分析任务频率和冷却时间的关系，可以较为直观地推导出可能的最短时间。

1. 首先，使用 `_.countBy` 函数统计每个任务出现的频率，并将频率值存储在 `freq` 对象中。
2. 对频率值进行排序，得到按从大到小的顺序排列的数组 `counts` ，方便获取最大的频率值 `maxExec` 。
3. 通过遍历 `counts` 数组，找到具有相同最大频率值的任务数量 `maxCount` 。
4. 最后，按照与原始解法相同的逻辑计算并返回最短时间间隔，即比较以最高频率任务为基准考虑冷却时间计算出的时间和任务总数，取较大值。

时间复杂度：O(nlogn)，主要开销在于对频率数组的排序操作。
空间复杂度：O(n)，用于存储任务频率和其他辅助变量。

```js
var leastInterval = function (tasks, n) {
  const freq = _.countBy(tasks);
  const counts = Object.values(freq).sort((a, b) => b - a);
  let maxExec = counts[0];
  let maxCount = 1;

  for (let i = 1; i < counts.length && counts[i] === maxExec; i++) {
    maxCount++;
  }

  return Math.max((maxExec - 1) * (n + 1) + maxCount, tasks.length);
};
```
