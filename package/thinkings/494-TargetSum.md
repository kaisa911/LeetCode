# 目标和

给你一个非负整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

示例 1：

```js
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

示例 2：

```js
输入：nums = [1], target = 1
输出：1
```

提示：

- 1 <= nums.length <= 20
- 0 <= nums[i] <= 1000
- 0 <= sum(nums[i]) <= 1000
- -1000 <= target <= 1000

思路：

题目的整理分析
对于这道题，我们需要在给定的非负整数数组中，通过在每个数字前添加 '+' 或 '-' 来构造表达式，使得表达式的计算结果等于给定的目标值 `target`。我们可以考虑使用回溯法来尝试所有可能的符号组合。选择回溯法的原因是它能够系统地遍历所有可能的添加符号的情况，从而找到满足条件的表达式数量。

1. 定义一个辅助函数 `helper` ，接受当前索引 `index` 和当前的总和 `sum` 。
2. 如果已经到达数组的末尾，判断总和是否等于目标值，若是则返回 1，否则返回 0 。
3. 根据当前的状态生成一个唯一的键 `key` 。
4. 如果这个键已经在 `dp` 对象中，直接返回其对应的值。
5. 否则计算当前状态下的结果，即向下一个索引移动并且分别加上和减去当前数字的情况，将结果相加并存储在 `dp[key]` 中，最后返回这个结果。

时间复杂度：O(n \* sum)，其中 `n` 是数组的长度，`sum` 是可能的总和范围。
空间复杂度：O(n \* sum)，主要用于存储动态规划的中间结果。

```js
var findTargetSumWays = function (nums, target) {
  let dp = {};
  const helper = (index, sum) => {
    if (index === nums.length) {
      return sum === target ? 1 : 0;
    }
    const key = `${index}-${sum}`;
    if (key in dp) {
      return dp[key];
    }
    dp[key] = helper(index + 1, sum + nums[index]) + helper(index + 1, sum - nums[index]);
    return dp[key];
  };
  return helper(0, 0);
};
```
