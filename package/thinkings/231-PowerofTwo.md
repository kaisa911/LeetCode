# 2 的幂

给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。

如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。

示例 1：

```javascript
输入：n = 1
输出：true
解释：20 = 1
```

示例 2：

```javascript
输入：n = 16
输出：true
解释：24 = 16
```

示例 3：

```javascript
输入：n = 3
输出：false
```

提示：

- -2^31 <= n <= 2^31 - 1

进阶：你能够不使用循环/递归解决此问题吗？

思路：
使用位运算，避免了循环和递归，实现了 O(1)的时间复杂度，并且代码简洁高效。

1. 检查 n 是否大于 0：因为 2 的幂次方总是正数，所以如果 n 小于等于 0，直接返回 false。
2. 位运算 n & (n - 1)：这个操作的目的是检查 n 的二进制表示中是否只有一个 1。如果 n 是 2 的幂次方，那么它的二进制表示中只有一个 1，其余都是 0。当我们执行 n - 1 时，会在 n 的二进制表示中将那个 1 变为 0，并在它右边的所有位上加 1。这样，n & (n - 1)的结果就会是 0，因为除了那个原本为 1 的位之外，其他位都是 0。
3. 返回结果：如果 n & (n - 1)的结果为 0，说明 n 是 2 的幂次方，返回 true；否则返回 false。

时间复杂度：O(1)。位运算的时间复杂度是常数级别的，不依赖于输入 n 的大小。
空间复杂度：O(1)。没有使用额外的空间，除了输入参数 n 之外。

```javascript
var isPowerOfTwo = function (n) {
  return n > 0 && (n & (n - 1)) === 0;
};
```
