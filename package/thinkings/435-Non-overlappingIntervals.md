# 无重叠区间

给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。

注意 只在一点上接触的区间是 不重叠的。例如 [1, 2] 和 [2, 3] 是不重叠的。

示例 1:

```js
输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

示例 2:

```js
输入: intervals = [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

示例 3:

```js
输入: intervals = [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

提示:

- 1 <= intervals.length <= 10^5
- intervals[i].length == 2
- -5 \* 10^4 <= starti < endi <= 5 \* 10^4

思路：

对于这个问题，我们的目标是找到需要移除的区间的最小数量，使得剩余区间互不重叠。

一种有效的思路是基于贪心算法。首先对区间按照右端点从小到大进行排序。然后从左到右遍历区间，尽可能选择右端点较小的区间，因为这样能给后面的区间留下更多的空间，从而减少重叠的可能性。

1. 首先判断如果区间集合为空，直接返回 0，因为不需要移除任何区间。
2. 对区间集合 intervals 按照区间的右端点从小到大进行排序，这样能方便后续的贪心选择。
3. 初始化变量 right 为第一个区间的右端点 intervals[0][1]，变量 ans 为 1，表示已经选择了一个区间。
4. 从第二个区间（索引为 1）开始遍历区间集合：
   - 如果当前区间的左端点大于等于 right，说明当前区间与已选区间不重叠，将 ans 加 1，并更新 right 为当前区间的右端点。
5. 最后返回 n - ans，其中 n 是区间集合的长度，ans 是不重叠区间的数量，n - ans 就是需要移除的区间数量。

时间复杂度：对区间集合进行排序的时间复杂度为 O(n log n)，其中 n 是区间集合的长度。遍历区间集合的时间复杂度为 O(n)。所以总的时间复杂度为 O(n log n)。
空间复杂度：只使用了常数级别的额外变量，空间复杂度为 O(1)。

```js
var eraseOverlapIntervals = function (intervals) {
  if (!intervals.length) {
    return 0;
  }

  intervals.sort((a, b) => a[1] - b[1]);

  const n = intervals.length;
  let right = intervals[0][1];
  let ans = 1;
  for (let i = 1; i < n; ++i) {
    if (intervals[i][0] >= right) {
      ++ans;
      right = intervals[i][1];
    }
  }
  return n - ans;
};
```
