# 腐烂的橘子

在给定的网格中，每个单元格可以有以下三个值之一：

值  0  代表空单元格；
值  1  代表新鲜橘子；
值  2  代表腐烂的橘子。
每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。

返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回  -1。

**示例 1：**

```js
输入：[[2,1,1],[1,1,0],[0,1,1]]
输出：4
```

**示例 2：**

```js
输入：[[2,1,1],[0,1,1],[1,0,1]]
输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。
```

**示例 3：**

```js
输入：[[0,2]]
输出：0
解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
```

**提示：**

- 1 <= grid.length <= 10
- 1 <= grid[0].length <= 10
- grid[i][j] 仅为 0、1 或 2

**思路：**
这个适用了 BFS 广度优先遍历。先遍历这一层的的腐烂的，然后找到周围新鲜的，然后把即将腐败的放到队列里，下次再继续判断，直到没有新鲜的橘子

1. 初始化：首先遍历整个网格，将所有腐烂橘子的位置存入一个队列中，并记录下当前的最小时间戳（因为任何腐烂橘子都会立即影响其相邻的橘子）。
2. 广度优先搜索（BFS）：只要队列不为空，就持续进行以下操作：
   - 取出队列头部的腐烂橘子位置，检查其四周的橘子（上下左右），如果发现新鲜的橘子，则将其变为腐烂，并更新时间戳，同时将新腐烂的橘子位置加入队列。
   - 时间戳随着每一层橘子的腐烂而增加。
3. 检查结果：在完成所有可能的腐烂传播后，再次遍历网格，如果还有任何新鲜的橘子存在，说明这些橘子无法腐烂，因此返回 -1；否则，返回记录的最大时间戳，即所有橘子腐烂所需的最小分钟数。

时间复杂度：O(N)，其中 N 是网格中的总单元格数。每个单元格最多被遍历两次（一次在初始遍历中，一次在腐烂传播中）。
空间复杂度：O(N)，用于存储队列中的橘子位置。

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var orangesRotting = function (grid) {
  let queue = []; // 统计新鲜的橘子

  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[i].length; j++) {
      if (grid[i][j] === 1) {
        queue.push([i, j]);
      }
    }
  }

  let time = 0;

  // 直到没有新鲜的橘子为止
  while (queue.length) {
    let next = []; // 储存下一轮新鲜的橘子
    let rot = []; // 储存下一轮腐烂的橘子

    // 遍历新鲜橘子，区分下一轮的新鲜橘子和腐烂橘子
    for (let k = 0; k < queue.length; k++) {
      let i = queue[k][0];
      let j = queue[k][1];
      if (
        (grid[i - 1] && grid[i - 1][j] === 2) ||
        (grid[i + 1] && grid[i + 1][j] === 2) ||
        grid[i][j - 1] === 2 ||
        grid[i][j + 1] === 2
      ) {
        // 四周有橘子，说明已腐烂
        rot.push([i, j]);
      } else {
        next.push([i, j]);
      }
    }

    // 这一轮没有腐烂的橘子，则返回-1
    if (!rot.length) {
      return -1;
    }

    // 把这一轮腐烂的橘子标记成2
    for (let i = 0; i < rot.length; i++) {
      grid[rot[i][0]][rot[i][1]] = 2;
    }

    queue = next;
    time++;
  }

  return time;
};
```
