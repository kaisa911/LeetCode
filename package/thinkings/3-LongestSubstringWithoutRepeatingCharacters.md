# 无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

**示例 1:**

```js
输入: "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

示例 2:

```js
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

示例 3:

```js
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

思路：

拿到这个题目，我们需要在给定的字符串中找到不含有重复字符的最长连续子串。由于要连续且不重复，所以可以使用滑动窗口的方法。通过一个指针标记窗口的起始位置，一个指针标记当前位置，随着遍历不断调整窗口大小，从而找到最长不重复子串。选择这种方法的理由是它能够有效地处理连续子串的问题，并且在遍历过程中实时更新最长子串的长度。

1. 首先判断字符串长度是否为 0，如果是则直接返回 0，这是对特殊情况的处理。
2. 初始化 `res` 为 1 ，用于存储最长无重复子串的长度，初始化 `left` 为 0 ，标记滑动窗口的起始位置。
3. 开始遍历字符串，对于每个字符，在 `left` 到当前位置的区间内查找是否出现过。
4. 如果出现过且位置在当前位置之前，说明有重复，将 `left` 移动到重复字符的下一个位置，以保证窗口内无重复字符。
5. 每次都更新 `res` 为当前无重复子串的长度和之前记录的最大长度中的较大值。

时间复杂度：O(n)，因为需要遍历字符串一次。
空间复杂度：O(min(m, n))，其中 m 为字符集大小，n 为字符串长度。在最坏情况下，存储字符出现情况的哈希表的大小与字符串长度相当。

```js
/**
 * @param {string} s
 * @return {number}
 */
const lengthOfLongestSubstring = (s) => {
  if (!s.length) return 0;
  // res 存储最长无重复子串的长度，初始值为1
  let res = 1,
    // 来标记滑动窗口的起始位置，初始值为0。
    left = 0;
  // 遍历字符串 s 对于每一个字符 s[i]，查找它在 left 到 i-1 这个区间内是否出现过
  for (let i = 0; i < s.length; i++) {
    let index = s.indexOf(s[i], left);
    // 如果在这个区间内找到了相同的字符，
    // 那么更新 left 为该字符的下一个位置。
    // 这样就保证了从 left 到 i 这个区间内没有重复的字符。
    if (index !== -1 && index < i) left = index + 1;

    // 更新 res 的值为当前无重复子串的长度和 res 中存储的最大长度之间的较大值。
    res = Math.max(res, i - left + 1);
  }
  return res;
};
```
