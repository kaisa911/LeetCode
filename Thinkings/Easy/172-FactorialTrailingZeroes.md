# 阶乘后的零

给定一个整数 n，返回 n! 结果尾数中零的数量。

**示例 1:**

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```

**示例  2:**

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

说明: 你算法的时间复杂度应为  O(log n) 。

**思路：**

首先题目的意思是末尾有几个 0

阶乘结果尾部零的数量由因子 2 和 5 的对数决定，因为 10 = 2 \* 5。然而，在阶乘中，因子 2 的数量总是大于或等于因子 5 的数量。因此，尾部零的数量实际上由因子 5 的数量决定。

1. 初始化计数器：定义变量 count 并初始化为 0，用于计数尾部零的数量。
2. 循环条件：使用 while 循环，条件是 n 大于等于 5。因为 5 和偶数相乘会产生尾部零，而 5 的因子比 2 的因子更稀有，所以只需要考虑 5 的倍数。
3. 计算 5 的倍数：在循环体内部，使用 Math.floor(n / 5)计算 n 中包含多少个 5 的倍数，并将这个值加到 count 上。
4. 更新 n：将 n 更新为其除以 5 的整数部分，继续下一次循环。
5. 返回结果：当 n 小于 5 时，循环结束，返回 count 作为最终尾部零的数量。

这种方法的时间复杂度是 O(log_5(n))，因为每次循环都将 n 除以 5，直到 n 小于 5。空间复杂度是 O(1)，因为只使用了常数级别的额外空间。

```js
/**
 * @param {number} n
 * @return {number}
 */
const trailingZeroes = (n) => {
  let count = 0; // 用于计数尾部零的数量
  // 循环除以5，因为每个5都会至少产生一个尾部零
  while (n >= 5) {
    count += Math.floor(n / 5); // 计算当前n中5的倍数的数量
    n = Math.floor(n / 5); // 更新n为除以5后的整数部分
  }
  return count; // 返回尾部零的总数
};
```
