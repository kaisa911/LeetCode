# 三数之和

给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请

你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例 1：

```js
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

示例 2：

```js
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

示例 3：

```js
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

提示：

- 3 <= nums.length <= 3000
- -105 <= nums[i] <= 105

**思路：**

**排序 + 双指针法**：首先对数组进行排序，然后使用双指针技术来找到和为 0 的三元组。这种方法的时间复杂度是 O(n^2)，效率更高。

使用排序 + 双指针法的详细步骤：

- 首先对数组进行排序。这样我们可以利用有序数组的性质来减少不必要的比较。
- 遍历排序后的数组，对于每一个元素 nums[i]，我们固定这个元素作为三元组的一个元素。
- 对于固定的元素 nums[i]，我们使用两个指针：一个左指针 j 指向 i+1，一个右指针 k 指向数组的最后一个元素。
- 我们检查当前的三个元素 nums[i] + nums[j] + nums[k] 是否为 0。
  - 如果它们的和大于 0，说明我们需要减小总和，因此我们将右指针向左移动一位（即 k--）。
  - 如果它们的和小于 0，说明我们需要增加总和，因此我们将左指针向右移动一位（即 j++）。
  - 如果它们的和正好为 0，我们就找到了一个三元组。为了避免重复的三元组，我们需要确保 j 至少比 i+1 大 1，k 至少比 i 小 1。然后将这个三元组添加到结果列表中，并移动两个指针（j++ 和 k--）。
- 为了避免在遍历过程中重复选择相同的元素，我们需要在每次找到三元组后，将左指针和右指针移动到下一个不同的元素。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
function threeSum(nums) {
  // 首先对数组进行排序
  nums.sort((a, b) => a - b);

  // 用于存储满足条件的三元组
  let triplets = [];

  // 遍历数组，寻找三元组
  for (let i = 0; i < nums.length - 2; i++) {
    // 固定当前元素 nums[i]
    if (i > 0 && nums[i] === nums[i - 1]) {
      // 跳过重复的元素
      continue;
    }

    let j = i + 1;
    let k = nums.length - 1;

    while (j < k) {
      // 检查当前三元素的和
      let sum = nums[i] + nums[j] + nums[k];

      if (sum === 0) {
        // 找到满足条件的三元组
        triplets.push([nums[i], nums[j], nums[k]]);

        // 为了避免重复的三元组，移动指针
        while (j < k && nums[j] === nums[j + 1]) {
          j++;
        }
        while (j < k && nums[k] === nums[k - 1]) {
          k--;
        }
      } else if (sum < 0) {
        // 如果和小于0，减小总和，移动左指针
        j++;
      } else {
        // 如果和大于0，增加总和，移动右指针
        k--;
      }
    }
  }

  return triplets;
}
```
